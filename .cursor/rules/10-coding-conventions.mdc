---
alwaysApply: false
---

### Coding conventions and structure

- Centralize constants in `utils/constants.ts`; do not duplicate literals.
- Types/interfaces live under `types/`; do not declare types outside.
- Configuration over conditionals: Prefer adding capabilities via configuration files (filters, categories) over branching code.
- Edge/server env: Follow safe fallbacks consistent with `getApiOrigin` (used by `proxy.ts`).
- No manual query strings: Use `URLSearchParams` and helpers.
- SSR/CSR balance: Keep SSR pages minimal, use client enhancement components as designed.
- Error handling: For reads, return safe fallbacks; for writes, surface backend error text before throwing.
- DRY: Before adding helpers/components, search existing utils/hooks/components (filters, URLs, i18n, images, forms). Reuse `next-intl` patterns (`getTranslations`/`useTranslations`, `i18n/routing`, `i18n/request`) and design-system primitives instead of introducing new ones.
- **Links: Always use `Link` from `@i18n/routing`** for internal navigation (not `next/link`). This ensures locale prefixes (`/es/`, `/en/`) are automatically handled. ESLint warns on `next/link` imports. Exceptions: primitives with manual locale handling, external-only links.
- Path aliases: Use `@app/*`, `@components/*`, `@utils/*`, `@lib/*`, `@config/*`, `types/*` (note: `types/*` without `@` to avoid collision with TypeScript's `@types` packages).
- Date formatting: Use `@utils/date-helpers.ts` (and `@lib/dates.ts` where applicable) instead of ad-hoc formatting.
- ESLint overrides: Do not fight rulesâ€”no `no-undef` in TS files, no inline type/interface declarations.
- Formatting: Preserve existing indentation and className patterns; avoid reformatting unrelated code.
