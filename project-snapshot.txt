<?xml version='1.0' encoding='utf-8'?>
<source type="github_repository"><commit>unknown</commit><file name=".eslintrc.json">{ "plugins": ["@typescript-eslint"], "extends": [ "eslint:recommended", "next", "next/core-web-vitals", "plugin:@typescript-eslint/recommended" ], "rules": { "no-unused-vars": "warn", "no-undef": "error", "no-debugger": "error", "react/react-in-jsx-scope": }, "env": { "es6": true, "browser": true, "node": true, "jest": true }, "overrides": [ { "files": ["public/sw.js", "public/sw-template.js"], "env": { "serviceworker": true }, "globals": { "workbox": "readonly", "importscripts": "readonly", "caches": "readonly", "self": "readonly" }, "rules": { "no-undef": } }, { "files": ["*.ts", "*.tsx"], "rules": { "no-undef": } }, { "files": [ "components/**/*.{ts,tsx,js,jsx}", "app/**/*.{ts,tsx,js,jsx}", "store.ts", "utils/**/*.{ts,tsx,js,jsx}" ], "rules": { "no-restricted-syntax": [ "error", { "selector": "tstypealiasdeclaration", "message": declare types outside /types directory. centralize type aliases /types." }, { "selector": "tsinterfacedeclaration", "message": declare interfaces outside /types directory. centralize interfaces /types." } ] } } ] }</file><file name=".yarnrc.yml">nodelinker: node-modules yarnpath: .yarn/releases/yarn-4.9.1.cjs</file><file name="README.md">[next.js](https://nextjs.org/) project bootstrapped [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app). ## getting started first, run development server: ```bash npm run dev # yarn dev ``` open [http://localhost:3000](http://localhost:3000) browser see result. start editing page modifying `pages/index.js`. page auto-updates edit file. [api routes](https://nextjs.org/docs/api-routes/introduction) accessed [http://localhost:3000/api/hello](http://localhost:3000/api/hello). endpoint edited `pages/api/hello.js`. `pages/api` directory mapped `/api/*`. files directory treated [api routes](https://nextjs.org/docs/api-routes/introduction) instead react pages. ## learn learn next.js, take look following resources: - [next.js documentation](https://nextjs.org/docs) - learn next.js features api. - [learn next.js](https://nextjs.org/learn) - interactive next.js tutorial. check next.js github repository](https://github.com/vercel/next.js/) - feedback contributions welcome! ## deploy vercel easiest way deploy next.js app use [vercel platform](https://vercel.com/new?utm_medium=default-template&amp;filter=next.js&amp;utm_source=create-next-app&amp;utm_campaign=create-next-app-readme) creators next.js. check [next.js deployment documentation](https://nextjs.org/docs/deployment) details.</file><file name="amplify.yml">version: 1 frontend: phases: prebuild: commands: # use yarn --frozen-lockfile fast, deterministic builds ci. - yarn install --frozen-lockfile # remove existing keys, write single, up-to-date copy - sed '/^next_public_build_id=/d' .env.production 2&gt;/dev/null || true - sed '/^next_telemetry_disabled=/d' .env.production 2&gt;/dev/null || true - | { echo "next_public_build_id=${aws_commit_id:-$(date echo "next_telemetry_disabled=1" } &gt;&gt; .env.production build: commands: - echo "building next.js application..." - test -f scripts/generate-sw.mjs || { echo "generate-sw.mjs missing"; exit 1; } - node scripts/generate-sw.mjs - yarn build artifacts: basedirectory: .next files: - "**/*" cache: paths: - node_modules/**/* - .next/cache/**/* - .yarn/cache/**/* # static asset caching configured optimal performance. # security headers dynamic content managed middleware.ts. # assets using getversionedurl() longer cache times. customheaders: # next.js built assets - automatically hashed, safe long cache - pattern: "/_next/static/**" headers: - key: cache-control value: "public, max-age=31536000, immutable" # next.js optimized images - 1 year cache (critical performance) - pattern: "/_next/image*" headers: - key: cache-control value: "public, max-age=31536000, immutable" # css files - safe long cache since /styles/non-critical.css uses getversionedurl - pattern: "/styles/**" headers: - key: cache-control value: "public, max-age=31536000, immutable" - key: content-type value: "text/css; charset=utf-8" # font files - longer cache cors headers cross-origin loading - pattern: "/static/fonts/**" headers: - key: cache-control value: "public, max-age=31536000, immutable" - key: access-control-allow-origin value: "*" - key: cross-origin-resource-policy value: "cross-origin" # static assets - conservative since may use getversionedurl - pattern: "/static/**" headers: - key: cache-control value: "public, max-age=2592000" # 30 days # static images user uploads) - conservative approach # separate patterns common image extensions (brace expansion supported) - pattern: "/static/**/*.png" headers: - key: cache-control value: "public, max-age=2592000" # 30 days - pattern: "/static/**/*.jpg" headers: - key: cache-control value: "public, max-age=2592000" # 30 days - pattern: "/static/**/*.jpeg" headers: - key: cache-control value: "public, max-age=2592000" # 30 days - pattern: "/static/**/*.gif" headers: - key: cache-control value: "public, max-age=2592000" # 30 days - pattern: "/static/**/*.webp" headers: - key: cache-control value: "public, max-age=2592000" # 30 days - pattern: "/static/**/*.svg" headers: - key: cache-control value: "public, max-age=2592000" # 30 days - pattern: "/static/**/*.ico" headers: - key: cache-control value: "public, max-age=2592000" # 30 days # fonts - longer cache since rarely change - pattern: "**/*.{woff,woff2,ttf,eot}" headers: - key: cache-control value: "public, max-age=31536000" # 1 year # api routes - cors headers functionality (middleware excludes - pattern: "/api/**" headers: - key: access-control-allow-origin value: "https://esdeveniments.cat" - key: access-control-allow-methods value: "get,options,patch,delete,post,put" - key: access-control-allow-headers value: "x-csrf-token, x-requested-with, accept, accept-version, content-length, content-md5, content-type, date, x-api-version" - key: vary value: "origin" - key: cache-control value: "public, max-age=3600" # 1 hour - conservative api responses # environment variables set amplify console better security. # go app settings &gt; environment variables # recommended variables: # node_env: production # next_telemetry_disabled: 1</file><file name="jest.config.js">const nextjest = require("next/jest"); const createjestconfig = nextjest({ dir: "./", }); const customjestconfig = { testenvironment: "jsdom", setupfilesafterenv: ["&lt;rootdir&gt;/test/setup.ts"], testpathignorepatterns: ["&lt;rootdir&gt;/.next/", "&lt;rootdir&gt;/node_modules/"], modulenamemapper: { "^@/(.*)$": "&lt;rootdir&gt;/$1", "^@components/(.*)$": "&lt;rootdir&gt;/components/$1", "^@utils/(.*)$": "&lt;rootdir&gt;/utils/$1", "^@config/(.*)$": "&lt;rootdir&gt;/config/$1", }, transform: { "^.+\\.(js|jsx|ts|tsx)$": ["babel-jest", { presets: ["next/babel"] }], }, testmatch: ["**/*.test.(js|jsx|ts|tsx)"], collectcoveragefrom: [ "components/**/*.{js,jsx,ts,tsx}", "utils/**/*.{js,jsx,ts,tsx}", "config/**/*.{js,jsx,ts,tsx}", "!**/*.d.ts", "!**/node_modules/**", ], }; module.exports = createjestconfig(customjestconfig);</file><file name="jest.config.ts">import nextjest 'next/jest'; import type { config } '@jest/types'; const createjestconfig = nextjest({ dir: './', }); const customjestconfig: config.initialoptions = { testenvironment: 'jsdom', setupfilesafterenv: ['&lt;rootdir&gt;/test/setup.ts'], testpathignorepatterns: ['&lt;rootdir&gt;/.next/', '&lt;rootdir&gt;/node_modules/'], modulenamemapper: { '^@/(.*)$': '&lt;rootdir&gt;/$1', '^@components/(.*)$': '&lt;rootdir&gt;/components/$1', '^@utils/(.*)$': '&lt;rootdir&gt;/utils/$1', '^@config/(.*)$': '&lt;rootdir&gt;/config/$1', }, transform: { '^.+\\.(js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }], }, testmatch: ['**/*.test.(js|jsx|ts|tsx)'], globals: { 'ts-jest': { tsconfig: { jsx: 'react', }, }, }, }; export default createjestconfig(customjestconfig);</file><file name="jest.setup.ts">// jest setup file typescript // learn https://github.com/testing-library/jest-dom import '@testing-library/jest-dom';</file><file name="jsconfig.json">{ "compileroptions": { "baseurl": ".", "paths": { "@store": ["store.js"], "@app/*": ["app/*"], "@components/*": ["components/*"], "@styles/*": ["styles/*"], "@content/*": ["content/*"], "@utils/*": ["utils/*"], "@lib/*": ["lib/*"], "@config/*": ["config/*"], "@public/*": ["public/*"], "@types/*": ["types/*"] }, "types": ["./types/react-datepicker.d.ts", "./types/navigator.d.ts"] } }</file><file name="middleware.ts">import { nextrequest, nextresponse } "next/server"; // determine environment development const isdev = process.env.node_env !== "production"; // get api origin multiple fallback strategies edge runtime // edge runtime limitations environment variables const getapiorigin = () =&gt; { // strategy 1: try environment variable (works cases) const apiurl = process.env.next_public_api_url; (apiurl) { try { return new url(apiurl).origin; } catch { console.warn("invalid next_public_api_url format:", apiurl); } } // strategy 2: fallback based node_env const nodeenv = process.env.node_env; (nodeenv === "production") { return "https://api.esdeveniments.cat"; // production api } // strategy 3: default fallback (development/staging) return "https://api-pre.esdeveniments.cat"; }; /** * generates balanced maintainable content security policy. * @param nonce - unique string 'nonce-' directive. * @returns csp string. */ function getcsp(nonce: string) { const apiorigin = getapiorigin(); const cspdirectives = { // default, allow resources domain. "default-src": ["'self'"], // --- script security important part) --- // gold standard. ensures scripts nonce run. // 'strict-dynamic' allows trusted script load scripts, // essential services like google ads analytics. // avoids whitelist every single google domain scripts. "script-src": [ "'self'", `'nonce-${nonce}'`, "'strict-dynamic'", isdev ? "'unsafe-eval'" : "", // next.js fast refresh dev isdev ? "localhost:*" : "", // allow localhost scripts dev next.js chunks isdev ? "127.0.0.1:*" : "", // allow 127.0.0.1 scripts dev next.js chunks ], // --- style security --- "style-src": ["'self'", "'unsafe-inline'"], // --- resources flexible maintainability) --- // instead whitelisting every domain, allow connections secure (https) source. // prevents services breaking change endpoints. "connect-src": [ "'self'", apiorigin, // dynamic external api based environment "https:", // allows https connection isdev ? "wss:" : "", // next.js fast refresh dev isdev ? "ws:" : "", // next.js fast refresh dev (non-secure) isdev ? "localhost:*" : "", // allow localhost connections dev isdev ? "127.0.0.1:*" : "", // allow 127.0.0.1 connections dev ], "img-src": ["'self'", "data:", "https:"], // allows https image "font-src": ["'self'"], "frame-src": ["'self'", "https:"], // allows https iframe // --- lockdown directives (hardening) --- "worker-src": ["'self'", "blob:"], "object-src": ["'none'"], // disallow plugins like flash "base-uri": ["'self'"], "form-action": ["'self'"], "frame-ancestors": ["'self'"], // prevents clickjacking // 'report-uri': 'your_sentry_reporting_endpoint', }; return object.entries(cspdirectives) .map(([key, value]) =&gt; `${key} ${value.filter(boolean).join(" ")}`) .join("; "); } export function middleware(request: nextrequest) { const { pathname } = request.nexturl; // --- handle service worker --- // apply specific caching headers service worker return early. (pathname === "/sw.js") { const response = nextresponse.next(); response.headers.set( "cache-control", "no-cache, no-store, must-revalidate" ); response.headers.set("service-worker-allowed", "/"); return response; } // --- handle redirects --- const segments = pathname.split("/").filter(boolean); ( (segments.length === 3 || segments.length === 2) &amp;&amp; segments[1] === "tots" ) { const newpath = segments.length === 3 ? `/${segments[0]}/${segments[2]}` : `/${segments[0]}`; const searchparams = request.nexturl.searchparams.tostring(); const finalurl = searchparams ? `${newpath}?${searchparams}` : newpath; return nextresponse.redirect(new url(finalurl, request.url), 301); } // --- generate apply security headers pages --- const nonce = crypto.randomuuid(); const csp = getcsp(nonce); const requestheaders = new headers(request.headers); requestheaders.set("x-nonce", nonce); requestheaders.set("x-pathname", pathname); const response = nextresponse.next({ request: { headers: requestheaders, }, }); response.headers.set("content-security-policy", csp); response.headers.set( "strict-transport-security", "max-age=63072000; includesubdomains; preload" ); response.headers.set("x-content-type-options", "nosniff"); response.headers.set("x-frame-options", "sameorigin"); response.headers.set("referrer-policy", "strict-origin-when-cross-origin"); response.headers.set( "permissions-policy", "camera=(), microphone=(), geolocation=(self)" ); return response; } export const config = { matcher: [ /* * match request paths except ones starting * - api (api routes) * - _next (next.js internal files) * - favicon.ico (favicon file) * - robots.txt, sitemap.xml, ads.txt (seo files) * - static (static assets) * - styles (css files) * - sw.js (service worker) */ "/((?!api|_next|favicon.ico|robots.txt|sitemap\\.xml|ads.txt|static|styles|sw\\.js).*)", ], };</file><file name="next-sitemap.config.js">const siteurl = process.env.node_env !== "production" ? "http://localhost:3000" : process.env.next_public_vercel_env === "preview" || process.env.next_public_vercel_env === "development" ? "https://esdeveniments.vercel.app" : "https://www.esdeveniments.cat"; module.exports = { siteurl, exclude: [ "api", "_app.js", "_document.js", "404.js", "_error.js", "sitemap.xml.js", "server-sitemap.xml", "server-sitemap.xml.js", "/server-sitemap.xml", "/server-sitemap.xml.js", "rss.xml", "/rss.xml", ".next", "___next_launcher.js", "___vc", "node_modules", "package.json", "e/[eventid]", "[place]", ], generaterobotstxt: true, robotstxtoptions: { policies: [ { useragent: "*", disallow: ["/404"], }, { useragent: "*", allow: "/" }, ], additionalsitemaps: [ `${siteurl}/sitemap.xml`, `${siteurl}/server-sitemap.xml`, ], }, };</file><file name="next-sitemap.d.ts">declare module 'next-sitemap' { export const getserversidesitemaplegacy: export type isitemapfield = }</file><file name="next.config.js">const { withsentryconfig } = require("@sentry/nextjs"); /** @type {import('next').nextconfig} */ const nextconfig = { // --- core settings --- reactstrictmode: true, poweredbyheader: false, compress: true, productionbrowsersourcemaps: true, // --- experimental features --- experimental: { scrollrestoration: true, reactcompiler: true, // react compiler experimental }, // --- optimizations --- compiler: { removeconsole: process.env.node_env === "production", }, // --- image optimization --- images: { // important: whitelist specific domains load images // using wildcards security risk. remotepatterns: [ { protocol: "https", hostname: "**" }, { protocol: "http", hostname: "**" }, ], devicesizes: [480, 640, 768, 1024, 1280, 1600, 1920], imagesizes: [16, 32, 48, 64, 96, 128, 256, 384], formats: ["image/avif", "image/webp"], minimumcachettl: 86400, }, // `headers` block removed. // security caching headers managed dynamically `middleware.ts`. // recommended approach implementing strict csp nonces. // --- redirects --- async redirects() { return []; }, }; const sentrywebpackpluginoptions = { silent: true, org: "esdeveniments", project: "javascript-nextjs", widenclientfileupload: true, transpileclientsdk: true, hidesourcemaps: true, disablelogger: true, automaticvercelmonitors: true, }; module.exports = withsentryconfig(nextconfig, sentrywebpackpluginoptions);</file><file name="package.json">{ "private": true, "scripts": { "analyze": "cross-env analyze=true next build", "analyze:server": "cross-env bundle_analyze=server next build", "analyze:browser": "cross-env bundle_analyze=browser next build", "vercel-build": "yarn run prebuild &amp;&amp; next build &amp;&amp; yarn run postbuild", "dev": "yarn run prebuild &amp;&amp; next dev", "build": "yarn run prebuild &amp;&amp; next build", "prebuild": "node scripts/generate-sw.mjs", "build:development": "node_env=development env-cmd -f .env.development yarn run prebuild &amp;&amp; env-cmd -f .env.development next build", "start:development": "env-cmd -f .env.development next start", "build:staging": "node_env=staging env-cmd -f .env.staging yarn run prebuild &amp;&amp; env-cmd -f .env.staging next build", "start:staging": "env-cmd -f .env.staging next start", "build:production": "node_env=production env-cmd -f .env.production yarn run prebuild &amp;&amp; env-cmd -f .env.production next build", "start:production": "node_env=production env-cmd -f .env.production next start", "postbuild": "next-sitemap", "start": "next start", "lint": "next lint", "test": "jest", "test:watch": "jest --watch", "typecheck": "tsc --noemit", "scan": "npx react-scan@latest localhost:3000" }, "dependencies": { "@headlessui/react": "^1.7.10", "@heroicons/react": "^1.0.6", "@sentry/nextjs": "^7.105.0", "@tailwindcss/aspect-ratio": "^0.4.2", "@tailwindcss/forms": "^0.5.3", "@tailwindcss/typography": "^0.5.9", "autoprefixer": "^10.4.20", "axios": "^1.4.0", "critters": "^0.0.25", "cssnano": "^7.0.6", "date-fns": "^2.29.3", "fast-xml-parser": "^4.4.0", "feed": "^4.2.2", "isomorphic-dompurify": "^2.25.0", "next": "^15.3.5", "postcss": "^8.5.1", "react": "^19.1.0", "react-datepicker": "^4.9.0", "react-dom": "^19.1.0", "react-select": "^5.7.0", "react-share": "^5.0.3", "react-tooltip": "^5.26.0", "swr": "^2.2.5", "tailwindcss": "^3.3.6", "zod": "3.24.3", "zustand": "^4.5.2" }, "devdependencies": { "@next/bundle-analyzer": "^13.1.6", "@testing-library/jest-dom": "^5.16.5", "@testing-library/react": "^14.0.0", "@testing-library/react-hooks": "^8.0.1", "@types/jest": "^30.0.0", "@types/node": "^22.9.1", "@types/react": "^19.0.7", "@types/react-datepicker": "^7.0.0", "@types/react-dom": "^18.3.1", "@typescript-eslint/eslint-plugin": "^8.30.1", "@typescript-eslint/parser": "^8.30.1", "babel-plugin-react-compiler": "^19.1.0-rc.1", "cross-env": "^7.0.3", "env-cmd": "^10.1.0", "eslint": "^8.57.0", "eslint-config-next": "^14.2.3", "eslint-plugin-react-hooks": "^6.0.0-rc.1", "jest": "^29.7.0", "jest-environment-jsdom": "^29.7.0", "next-sitemap": "^4.2.3", "prettier-eslint": "^15.0.1", "ts-node": "^10.9.2", "ttf2woff2": "^8.0.0", "typescript": "^5.6.3" }, "packagemanager": "yarn@4.9.1", "browserslist": [ "&gt; 1%", "last 2 versions", dead", ie 11" ] }</file><file name="postcss.config.js">module.exports = { plugins: { tailwindcss: {}, autoprefixer: {}, cssnano: { preset: "default" }, }, };</file><file name="sentry.client.config.ts">// file configures initialization sentry client. // config add used whenever users loads page browser. // https://docs.sentry.io/platforms/javascript/guides/nextjs/ import { init } '@sentry/nextjs'; import type { browseroptions } '@sentry/nextjs'; const sentryclientconfig = { // add sentry client config }; (process.env.node_env === 'production') { const config: browseroptions = { dsn: process.env.next_public_sentry_dns, environment: process.env.next_public_vercel_env, tracessamplerate: 1.0, replaysonerrorsamplerate: 1.0, replayssessionsamplerate: 0.1, debug: false, }; init(config); } export default sentryclientconfig;</file><file name="sentry.edge.config.ts">// file configures initialization sentry edge features (middleware, edge routes, etc). // config add used whenever one edge features loaded. // https://docs.sentry.io/platforms/javascript/guides/nextjs/ import { init } '@sentry/nextjs'; import type { edgeoptions } '@sentry/nextjs'; (process.env.node_env === 'production') { const config: edgeoptions = { dsn: process.env.next_public_sentry_dns, environment: process.env.next_public_vercel_env, tracessamplerate: 1.0, debug: false, }; init(config); }</file><file name="sentry.server.config.ts">// file configures initialization sentry server. // config add used whenever page built server ssr used. // https://docs.sentry.io/platforms/javascript/guides/nextjs/ import { init } '@sentry/nextjs'; import type { nodeoptions } '@sentry/nextjs'; (process.env.node_env === 'production') { const config: nodeoptions = { dsn: process.env.sentry_dsn, environment: process.env.next_public_vercel_env, tracessamplerate: 1.0, debug: false, }; init(config); }</file><file name="store.ts">import { create } "zustand"; import { persist, createjsonstorage } "zustand/middleware"; // base interfaces export interface userlocation { latitude: number; longitude: number; } export interface eventlocation { latitude: number; longitude: number; } export enum eventcategory { "festes majors" = "festa major", festivals = "festival", familiar = "familiar", msica = "msica", cinema = "cinema", teatre = "teatre", exposicions = "exposici", fires = "fira", espectacles = "espectacles", } // dynamic category interface new system export interface dynamiceventcategory { id: number; name: string; slug: string; } // union type transition period - supports legacy dynamic export type eventcategorytype = eventcategory | dynamiceventcategory | string; // note: following event interface frontend-only transformed events. // backend-aligned event data, use eventsummaryresponsedto listevent types/api/event. export interface event { id: string; title: string; description: string; image: string; /** url image uploaded user */ imageuploaded?: string; /** url image associated event */ imageurl: string; url: string; startdate: string; enddate: string; starttime: string; endtime: string; place: string; category: eventcategory | ""; distance?: number; location?: string; sublocation?: string; postalcode?: string; slug: string; isad?: boolean; formattedstart: string; formattedend?: string; isfulldayevent: boolean; duration: string; timeuntilevent: string; videourl?: string; nameday: string; weather?: { description?: string; icon?: string; }; } // filter state interface - removed: filters live url // url single source truth place, bydate, category, searchterm, distance // ui state interface interface uistate { openmodal: boolean; hydrated: boolean; } // combined store state interface - url-first, minimal state export interface storestate extends uistate { userlocation: userlocation | null; } // store actions interface - simplified export interface storeactions { setstate: &lt;k extends keyof storestate&gt;(key: k, value: storestate[k]) =&gt; void; sethydrated: () =&gt; void; } // complete store type export type store = storestate &amp; storeactions; // create store minimal state const usestore = create&lt;store&gt;()( persist( (set) =&gt; ({ // initial ui state openmodal: false, hydrated: false, // initial user location userlocation: null, // actions setstate: (key, value) =&gt; { set((state) =&gt; { // update specific property avoid unnecessary re-renders (state[key] === value) return state; // skip value changed return { ...state, [key]: value }; }); }, sethydrated: () =&gt; { set((state) =&gt; ({ ...state, hydrated: true })); }, }), { name: "events-ui", storage: createjsonstorage(() =&gt; localstorage), partialize: (state) =&gt; ({ // persist ui state survive browser restarts hydrated: state.hydrated, }), } ) ); export default usestore;</file><file name="tailwind.config.js">/** @type {import('tailwindcss').config} */ module.exports = { content: ["./components/**/*.{js,ts,jsx,tsx}", "./app/**/*.{js,ts,jsx,tsx}"], theme: { extend: { fontfamily: { roboto: ["var(--font-roboto-flex)", "sans-serif"], barlow: ["var(--font-barlow-condensed)", "sans-serif"], }, screens: { xs: "360px", sm: "576px", md: "768px", lg: "1024px", xl: "1280px", }, animation: { "fast-pulse": "fast-pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", "fast-pulse1": "fast-pulse 300ms cubic-bezier(0.4, 0, 0.6, 1) 100ms", appear: "appear 500ms", disappear: "disappear 500ms", }, keyframes: { "fast-pulse": { "0%, 100%": { opacity: 1 }, "50%": { opacity: 0 }, }, appear: { "0%": { opacity: 0 }, "100%": { opacity: 1 }, }, disappear: { "0%": { opacity: 1 }, "100%": { opacity: 0 }, }, }, boxshadow: { lg: "4px 4px 9px -3px #45454590", }, flex: { 2: "2 2 0%", 3: "3 3 0%", 4: "4 4 0%", }, zindex: { 1: "1", 900: "900", }, }, colors: { primary: "#ff0037", primarydark: "#c8033f", primarysoft: "#ff003750", whitecorp: "#ffffff", darkcorp: "#f7f7f7", blackcorp: "#454545", bcolor: "#cccccc", }, }, variants: { extend: { opacity: ["disabled"], cursor: ["disabled"], }, }, plugins: [ require("@tailwindcss/aspect-ratio"), require("@tailwindcss/typography"), require("@tailwindcss/forms"), ], };</file><file name="tsconfig.json">{ "compileroptions": { "target": "es2021", "lib": [ "dom", "dom.iterable", "esnext" ], "allowjs": false, "skiplibcheck": true, "strict": true, "noemit": true, "esmoduleinterop": true, "module": "esnext", "moduleresolution": "bundler", "resolvejsonmodule": true, "isolatedmodules": true, "jsx": "preserve", "incremental": true, "downleveliteration": true, "plugins": [ { "name": "next" } ], "baseurl": ".", "paths": { "@store": [ "store.ts" ], "@app/*": [ "app/*" ], "@components/*": [ "components/*" ], "@styles/*": [ "styles/*" ], "@content/*": [ "content/*" ], "@utils/*": [ "utils/*" ], "@lib/*": [ "lib/*" ], "@config/*": [ "config/*" ], "@public/*": [ "public/*" ], "@types/*": [ "types/*" ], "react": [ "./node_modules/@types/react" ] }, "noimplicitreturns": true, "nofallthroughcasesinswitch": true, "nounusedlocals": true, "nounusedparameters": true, "types": [ "./types/react-datepicker.d.ts" ] }, "include": [ "**/*.ts", "**/*.tsx", "next-env.d.ts", "next.config.js", "postcss.config.js", "tailwind.config.js", ".next/types/**/*.ts" ], "exclude": [ "node_modules", ".next" ] }</file><file name=".cursor/rules/README.md"># apm framework - optional cursor ide rules directory, `rules/` (intended mirrored `.cursor/rules/` user's project choose use feature), contains optional [cursor ide rules](https://docs.cursor.com/context/rules). rules designed enhance robustness efficiency agentic project management (apm) framework used within cursor ide. use entirely optional primarily benefits users operating apm within cursor.** core apm prompts designed function effectively without rules. ## rules work cursor rules allow provide persistent, scoped instructions ai. context, manager agent prompted conditional "self-notes" specific points core protocols (e.g., `01_initiation_prompt.md` `02_codebase_guidance.md`). self-notes suggest user cursor rules enabled deems helpful, *may consider requesting* relevant rule name (e.g., `@rule_name`). approach ensures: 1. **optionality:** apm framework break rules used used outside cursor. 2. **targeted assistance:** rules invoked potentially beneficial specific, fragile parts workflow. 3. **contextual relevance:** ai (manager agent) uses rule's description current operational context decide activating rule appropriate. ## available rules (supporting manager agent) ### general initiation &amp; planning phase * **`apm_discovery_synthesis_reminder.mdc`** * **description rule):** gathered extensive info (e.g., via `codebase_search`, `read_file`), rule prompts synthesize findings, identify next steps planning, explicitly consult user deep-diving `implementation_plan.md` generation. helps prevent premature planning based incomplete synthesis." * **purpose:** aids manager agent transitioning information gathering (discovery) structured planning, ensuring user alignment committing detailed plan. * **`apm_plan_format_source.mdc`** * **description rule):** "reminds `01_implementation_plan_guide.md` authoritative source formatting `implementation_plan.md`." * **purpose:** ensures uses correct guide tasked generating modifying implementation plan, promoting consistency. * **`apm_memory_system_format_source.mdc`** * **description rule):** "reminds `02_memory_bank_guide.md` authoritative source memory bank system setup (single vs multi-file) initial file headers." * **purpose:** ensures uses correct guide proposing setting project's memory bank, aligning project complexity. ### implementation plan integrity * **`apm_impl_plan_critical_elements_reminder.mdc`** (new) * **description rule):** "reminder implementation plan: ensure 1) explicit agent assignment (consider distribution) 2) 'guiding notes' critical action steps defined tasks." * **purpose:** reinforces necessity assigning agents every task including crucial "guiding notes" methodological consistency directly within `implementation_plan.md`. helps prevent ambiguity ensures tasks well-defined subsequent agent assignment. ### memory system integrity * **`apm_memory_naming_validation_reminder.mdc`** (new) * **description rule):** "reminder: validate memory bank file/directory names implementation plan creation. adhere conventions 02_memory_bank_guide.md." * **purpose:** promotes strict adherence memory bank naming conventions validation `implementation_plan.md` file directory created. crucial preventing structural errors memory bank. ### task assignment consistency * **`apm_task_prompt_plan_guidance_incorporation_reminder.mdc`** (new) * **description rule):** "reminder task assignment prompts: explicitly incorporate expand upon 'guiding notes' found implementation plan's action steps." * **purpose:** ensures manager agent generates detailed `task assignment prompts`, correctly uses elaborates "guiding notes" provided `implementation_plan.md`. maintains consistent line instruction high-level plan detailed task execution. ## using rules cursor 1. clone apm framework, `rules/` directory included. 2. make rules active cursor project, copy contents `rules/` directory `.cursor/rules/` directory root project. 3. ensure "project rules" enabled cursor settings.</file><file name=".github/CODEOWNERS">* @albertolive</file><file name=".github/ISSUE_TEMPLATE.md">&lt;!--- provide general summary issue title --&gt; &lt;!--- posting question, get rid rest template --&gt; ## expected behavior &lt;!--- describing bug, tell us happen --&gt; &lt;!--- suggesting change/improvement, tell us work --&gt; ## current behavior &lt;!--- describing bug, tell us happens instead expected behavior --&gt; &lt;!--- suggesting change/improvement, explain difference current behavior --&gt; ## possible solution &lt;!--- obligatory, suggest fix/reason bug, --&gt; &lt;!--- ideas implement addition change --&gt; ## steps reproduce bugs) &lt;!--- provide link live example, unambiguous set steps --&gt; &lt;!--- reproduce bug. include code reproduce, relevant --&gt; 1. 2. 3. 4. ## context &lt;!--- issue affected trying accomplish? --&gt; &lt;!--- providing context helps us come solution useful real world --&gt; ## environment &lt;!--- include many relevant details environment experienced bug --&gt; - version used: - environment name version (e.g. node 18 macos): - server type version: - operating system version: - link project:</file><file name=".github/PULL_REQUEST_TEMPLATE.md" /><file name="app/GoogleScripts.tsx">"use client"; import script "next/script"; import { googlescriptsprops } "types/props"; export default function googlescripts({ nonce }: googlescriptsprops) { return ( &lt;&gt; {/* google analytics */} &lt;script id="google-analytics-gtag" strategy="afterinteractive" src={`https://www.googletagmanager.com/gtag/js?id=${process.env.next_public_google_analytics}`} nonce={nonce} /&gt; &lt;script id="google-analytics-lazy-load" strategy="afterinteractive" nonce={nonce} &gt; {` window.datalayer = window.datalayer || []; function gtag(){datalayer.push(arguments);} gtag('js', new date()); gtag('config', '${process.env.next_public_google_analytics}', { page_path: window.location.pathname, }); `} &lt;/script&gt; {/* google ads */} &lt;script id="google-ads" strategy="afterinteractive" crossorigin="anonymous" src={`https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${process.env.next_public_google_ads}`} nonce={nonce} /&gt; &lt;script id="google-adblock" strategy="afterinteractive" nonce={nonce}&gt; {` (function() { function signalgooglefcpresent() { (!window.frames['googlefcpresent']) { (document.body) { const iframe = document.createelement('iframe'); iframe.style = 'width: 0; height: 0; border: none; z-index: -1000; left: -1000px; top: -1000px;'; iframe.style.display = 'none'; iframe.name = 'googlefcpresent'; document.body.appendchild(iframe); } else { settimeout(signalgooglefcpresent, 0); } } } signalgooglefcpresent(); })(); `} &lt;/script&gt; &lt;script src="https://fundingchoicesmessages.google.com/i/pub-2456713018173238?ers=1" strategy="afterinteractive" nonce={nonce} /&gt; &lt;/&gt; ); }</file><file name="app/error.tsx">"use client"; import { useeffect } "react"; import * sentry "@sentry/nextjs"; export default function error({ error, reset }: { error: error; reset: () =&gt; void }) { useeffect(() =&gt; { (error) { sentry.captureexception(error); } }, [error]); return ( &lt;div style={{ padding: 32, textalign: "center" }}&gt; &lt;h1&gt;alguna cosa ha anat malament&lt;/h1&gt; &lt;p&gt;{error?.message || "si us plau, torna-ho intentar."}&lt;/p&gt; &lt;button onclick={reset} style={{ margintop: 16 }}&gt; torna carregar &lt;/button&gt; &lt;/div&gt; ); }</file><file name="app/global-error.tsx">"use client"; import * sentry "@sentry/nextjs"; export default function globalerror({ error, reset, }: { error: error; reset: () =&gt; void; }) { sentry.captureexception(error); return ( &lt;html&gt; &lt;body&gt; &lt;h2&gt;alguna cosa ha anat malament (global)&lt;/h2&gt; &lt;button onclick={() =&gt; reset()}&gt;torna carregar&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; ); }</file><file name="app/layout.tsx">import "../styles/critical.css"; import type { reactnode } "react"; import type { metadata, viewport } "next"; import { headers } "next/headers"; import googlescripts "./googlescripts"; import { baselayout } "@components/ui/layout"; import websiteschema "@components/partials/websiteschema"; import criticalcss "@components/partials/criticalcss"; import { robotoflex, barlowcondensed } "../lib/fonts"; export const metadata: metadata = { { "mobile-web-app-capable": "yes", "apple-mobile-web-app-status-bar-style": "default", }, alternates: { types: { "application/rss+xml": [{ url: "/rss.xml", title: "rss" }], }, }, }; export const viewport: viewport = { width: "device-width", initialscale: 1, themecolor: "#000000", }; export default async function rootlayout({ children, }: { children: reactnode; }) { // read nonce middleware headers const headerslist = await headers(); const nonce = headerslist.get("x-nonce") || ""; return ( &lt;html lang="ca" classname={`${robotoflex.variable} ${barlowcondensed.variable}`} &gt; &lt;body&gt; &lt;link rel="preconnect" href="https://www.googletagmanager.com" /&gt; &lt;link rel="preconnect" href="https://www.google-analytics.com" /&gt; &lt;link rel="preconnect" href="https://pagead2.googlesyndication.com" /&gt; &lt;link rel="dns-prefetch" href="//cdnjs.cloudflare.com" /&gt; &lt;link rel="dns-prefetch" href="//www.google-analytics.com" /&gt; &lt;websiteschema nonce={nonce} /&gt; &lt;criticalcss /&gt; &lt;googlescripts nonce={nonce} /&gt; &lt;baselayout&gt;{children}&lt;/baselayout&gt; &lt;/body&gt; &lt;/html&gt; ); }</file><file name="app/manifest.ts">import type { metadataroute } "next"; export default function manifest(): metadataroute.manifest { return { name: "esdeveniments.cat", short_name: "esdeveniments", description: "descobreix els millors esdeveniments culturals de catalunya", start_url: "/", display: "standalone", background_color: "#ffffff", theme_color: "#000000", orientation: "portrait-primary", categories: ["entertainment", "lifestyle", "culture"], lang: "ca", dir: "ltr", icons: [ { src: "/static/icons/icon-192x192.png", sizes: "192x192", type: "image/png", purpose: }, { src: "/static/icons/icon-512x512.png", sizes: "512x512", type: "image/png", purpose: }, ], screenshots: [ { src: "/static/icons/icon-512x512.png", sizes: "512x512", type: "image/png", form_factor: "narrow", label: "mobile view esdeveniments.cat", }, { src: "/static/icons/icon-512x512.png", sizes: "512x512", type: "image/png", form_factor: "wide", label: "desktop view esdeveniments.cat", }, ], shortcuts: [ { name: "esdeveniments de barcelona", short_name: "barcelona", description: "veure esdeveniments de barcelona", url: "/barcelona", icons: [ { src: "/static/icons/today-icon.png", sizes: "96x96", type: "image/png", }, ], }, { name: "esdeveniments de girona", short_name: "girona", description: "veure esdeveniments de girona", url: "/girona", icons: [ { src: "/static/icons/today-icon.png", sizes: "96x96", type: "image/png", }, ], }, { name: "esdeveniments de catalunya", short_name: "catalunya", description: "veure tots els esdeveniments de catalunya", url: "/catalunya", icons: [ { src: "/static/icons/today-icon.png", sizes: "96x96", type: "image/png", }, ], }, { name: "publica un esdeveniment", short_name: "publica", description: "publica un nou esdeveniment", url: "/publica", icons: [ { src: "/static/icons/today-icon.png", sizes: "96x96", type: "image/png", }, ], }, ], }; }</file><file name="app/not-found.tsx">"use client"; export default function notfound() { return ( &lt;div style={{ padding: 32, textalign: "center" }}&gt; &lt;h1&gt;pgina trobada&lt;/h1&gt; &lt;p&gt;no s&amp;apos;ha pogut trobar la pgina que busques.&lt;/p&gt; href="/" style={{ color: "#0070f3", textdecoration: "underline" }}&gt; torna l&amp;apos;inici &lt;/div&gt; ); }</file><file name="app/page.tsx">import { fetchcategorizedevents } "@lib/api/events"; import { fetchcategories } "@lib/api/categories"; import { generatepagesdata } "@components/partials/generatepagesdata"; import { buildpagemeta } "@components/partials/seo-meta"; import type { pagedata } "types/common"; import { categorizedevents } "types/api/event"; import type { categorysummaryresponsedto } "types/api/category"; import servereventscategorized "@components/ui/servereventscategorized"; import search "@components/ui/search"; import { suspense, jsx } "react"; export async function generatemetadata() { const pagedata: pagedata = await generatepagesdata({ currentyear: new date().getfullyear(), place: "", bydate: "", }); return buildpagemeta({ title: pagedata.metatitle, description: pagedata.metadescription, canonical: pagedata.canonical, }); } export default async function page(): promise&lt;jsx.element&gt; { // always fetch categorized events url filters support) const categorizedevents: categorizedevents = await fetchcategorizedevents(5); // fetch dynamic categories enhanced category support let categories: categorysummaryresponsedto[] = []; try { categories = await fetchcategories(); } catch (error) { // continue without categories - components use static fallbacks console.error("error fetching categories:", error); categories = []; } const pagedata: pagedata = await generatepagesdata({ currentyear: new date().getfullyear(), place: "", bydate: "", }); return ( &lt;&gt; &lt;div classname="w-full flex justify-center items-center mx-auto px-2 lg:px-0 sm:w-[580px] md:w-[768px] lg:w-[1024px]"&gt; &lt;suspense fallback={ &lt;div classname="w-full h-12 bg-whitecorp animate-pulse rounded-full" /&gt; } &gt; &lt;search /&gt; &lt;/suspense&gt; &lt;/div&gt; &lt;servereventscategorized categorizedevents={categorizedevents} pagedata={pagedata} categories={categories} /&gt; &lt;/&gt; ); }</file><file name="app/[place]/page.tsx">import { redirect } "next/navigation"; import { headers } "next/headers"; import script "next/script"; import { fetchevents, insertads } "@lib/api/events"; import { fetchcategories } "@lib/api/categories"; import { getplacetypeandlabel } "@utils/helpers"; import { fetchregionswithcities, fetchregions } "@lib/api/regions"; import { generatepagesdata } "@components/partials/generatepagesdata"; import { buildpagemeta, generateitemliststructureddata, } "@components/partials/seo-meta"; import type { placestaticpathparams, placetypeandlabel, pagedata, } "types/common"; import type { categorysummaryresponsedto } "types/api/category"; import type { eventcategory } "@store"; import { fetcheventsparams } "types/event"; import hybrideventslist "@components/ui/hybrideventslist"; import clientinteractivelayer "@components/ui/clientinteractivelayer"; import { buildcanonicalurl } "@utils/url-filters"; import { validateplaceorthrow, validateplaceformetadata, } "@utils/route-validation"; import { iseventsummaryresponsedto } "types/api/iseventsummaryresponsedto"; import { fetchcities } "@lib/api/cities"; export const revalidate = 600; export async function generatestaticparams() { const [regions, cities] = await promise.all([fetchregions(), fetchcities()]); return [ ...regions.map((region) =&gt; ({ place: region.slug })), ...cities.map((city) =&gt; ({ place: city.slug })), ]; } export async function generatemetadata({ params, }: { params: promise&lt;placestaticpathparams&gt;; }) { const { place } = await params; const validation = validateplaceformetadata(place); (!validation.isvalid) { return validation.fallbackmetadata; } const placetypelabel: placetypeandlabel = await getplacetypeandlabel(place); const pagedata: pagedata = await generatepagesdata({ currentyear: new date().getfullyear(), place, bydate: "", placetypelabel, }); return buildpagemeta({ title: pagedata.metatitle, description: pagedata.metadescription, canonical: pagedata.canonical, }); } export default async function page({ params, searchparams, }: { params: promise&lt;placestaticpathparams&gt;; searchparams: promise&lt;{ [key: string]: string | string[] | undefined }&gt;; }) { const { place } = await params; const search = await searchparams; // read nonce middleware headers const headerslist = await headers(); const nonce = headerslist.get("x-nonce") || ""; validateplaceorthrow(place); const urlsearchparams = new urlsearchparams(); object.entries(search).foreach(([key, value]) =&gt; { (typeof value === "string") { urlsearchparams.set(key, value); } else (array.isarray(value)) { urlsearchparams.set(key, value[0]); } }); const category = typeof search.category === "string" ? search.category : undefined; const date = typeof search.date === "string" ? search.date : undefined; const distance = typeof search.distance === "string" ? search.distance : undefined; const lat = typeof search.lat === "string" ? search.lat : undefined; const lon = typeof search.lon === "string" ? search.lon : undefined; const query = typeof search.search === "string" ? search.search : undefined; (category || date) { const canonicalurl = buildcanonicalurl({ place, bydate: date || "tots", category: (category eventcategory) || "tots", searchterm: query || "", distance: distance ? parseint(distance) : 50, lat: lat ? parsefloat(lat) : undefined, lon: lon ? parsefloat(lon) : undefined, }); redirect(canonicalurl); } const fetchparams: fetcheventsparams = { page: 0, size: 10, }; (place !== "catalunya") { fetchparams.place = place; } (category) fetchparams.category = category; // add distance/radius filter coordinates provided (lat &amp;&amp; lon) { (distance) { fetchparams.radius = parseint(distance); } fetchparams.lat = parsefloat(lat); fetchparams.lon = parsefloat(lon); } // add search query provided (query) { fetchparams.term = query; } let eventsresponse = await fetchevents(fetchparams); let noeventsfound = false; ( !eventsresponse || !eventsresponse.content || eventsresponse.content.length === 0 ) { const regionswithcities = await fetchregionswithcities(); const regionwithcities = regionswithcities.find((r) =&gt; r.cities.some((city) =&gt; city.value === place) ); (regionwithcities) { const regions = await fetchregions(); const regionwithslug = regions.find((r) =&gt; r.id === regionwithcities.id); (regionwithslug) { eventsresponse = await fetchevents({ page: 0, size: 7, place: regionwithslug.slug, }); noeventsfound = true; } } } // final fallback: still events, fetch latest events filters (like catalunya homepage) ( !eventsresponse || !eventsresponse.content || eventsresponse.content.length === 0 ) { eventsresponse = await fetchevents({ page: 0, size: 7, // place, category, filters - get latest events }); noeventsfound = true; } const events = eventsresponse?.content || []; const eventswithads = insertads(events); let categories: categorysummaryresponsedto[] = []; try { categories = await fetchcategories(); } catch (error) { console.error("error fetching categories:", error); } const placetypelabel: placetypeandlabel = await getplacetypeandlabel(place); const pagedata = await generatepagesdata({ currentyear: new date().getfullyear(), place, bydate: "", placetypelabel, }); const validevents = events.filter(iseventsummaryresponsedto); const structureddata = validevents.length &gt; 0 ? generateitemliststructureddata(validevents, `esdeveniments ${place}`) : null; return ( &lt;&gt; {/* json-ld structured data */} {structureddata &amp;&amp; ( &lt;script id={`events-${place}`} type="application/ld+json" strategy="afterinteractive" nonce={nonce} dangerouslysetinnerhtml={{ __html: json.stringify(structureddata), }} /&gt; )} {/* server-rendered events content (seo optimized) */} &lt;hybrideventslist initialevents={eventswithads} placetypelabel={placetypelabel} pagedata={pagedata} noeventsfound={noeventsfound} place={place} category={category} date={date} serverhasmore={!eventsresponse?.last} /&gt; {/* client-side interactive layer (search, filters, floating button) */} &lt;clientinteractivelayer categories={categories} placetypelabel={placetypelabel} /&gt; &lt;/&gt; ); }</file><file name="app/[place]/[byDate]/page.tsx">import script "next/script"; import { fetchevents, insertads } "@lib/api/events"; import { fetchcategories } "@lib/api/categories"; import { getplacetypeandlabel, tolocaldatestring } "@utils/helpers"; import { generatepagesdata } "@components/partials/generatepagesdata"; import { buildpagemeta, generateitemliststructureddata, } "@components/partials/seo-meta"; import { today, tomorrow, week, weekend, twoweeksdefault } "@lib/dates"; import type { datefunctions } "types/dates"; import { placetypeandlabel, bydateoptions } "types/common"; import type { categorysummaryresponsedto } "types/api/category"; import { fetcheventsparams } "types/event"; import { fetchregionswithcities, fetchregions } "@lib/api/regions"; import hybrideventslist "@components/ui/hybrideventslist"; import clientinteractivelayer "@components/ui/clientinteractivelayer"; import { parsefiltersfromurl } "@utils/url-filters"; import { validateplaceorthrow, validateplaceformetadata, } "@utils/route-validation"; import { iseventsummaryresponsedto } "types/api/iseventsummaryresponsedto"; export async function generatemetadata({ params, }: { params: promise&lt;{ place: string; bydate: string }&gt;; }) { const { place, bydate } = await params; const validation = validateplaceformetadata(place); (!validation.isvalid) { return validation.fallbackmetadata; } let categories: categorysummaryresponsedto[] = []; try { categories = await fetchcategories(); } catch (error) { console.error("generatemetadata: error fetching categories:", error); } const parsed = parsefiltersfromurl( { place, date: bydate }, new urlsearchparams(), categories ); const actualdate = parsed.segments.date; const actualcategory = parsed.segments.category; const placetypelabel: placetypeandlabel = await getplacetypeandlabel(place); const categorydata = categories.find((cat) =&gt; cat.slug === actualcategory); const pagedata = await generatepagesdata({ currentyear: new date().getfullyear(), place, bydate: actualdate bydateoptions, placetypelabel, category: actualcategory &amp;&amp; actualcategory !== "tots" ? actualcategory : undefined, categoryname: categorydata?.name, }); return buildpagemeta({ title: pagedata.metatitle, description: pagedata.metadescription, canonical: pagedata.canonical, }); } export async function generatestaticparams() { const topplaces = ["catalunya", "barcelona", "girona", "lleida", "tarragona"]; const topdates = [ "avui", "dema", "setmana", "cap-de-setmana", ] bydateoptions[]; let categories: categorysummaryresponsedto[] = []; try { categories = await fetchcategories(); } catch (error) { console.error("generatestaticparams: error fetching categories:", error); } const topcategories = categories.slice(0, 4).map((cat) =&gt; cat.slug); const combinations = []; (const place topplaces) { (const date topdates) { combinations.push({ place, bydate: date }); } (const category topcategories) { combinations.push({ place, bydate: category }); } } return combinations; } export default async function bydatepage({ params, searchparams, }: { params: promise&lt;{ place: string; bydate: string }&gt;; searchparams: promise&lt;{ [key: string]: string | string[] | undefined }&gt;; }) { const { place, bydate } = await params; const search = await searchparams; validateplaceorthrow(place); let categories: categorysummaryresponsedto[] = []; try { categories = await fetchcategories(); } catch (error) { console.error( " [place]/[bydate]/page.tsx - error fetching categories:", error ); categories = []; } const parsed = parsefiltersfromurl( { place, date: bydate }, new urlsearchparams(), categories ); const actualdate = parsed.segments.date; const actualcategory = parsed.segments.category; const searchcategory = typeof search.category === "string" ? search.category : undefined; const finalcategory = searchcategory || actualcategory; const datefunctions: datefunctions = { avui: today, dema: tomorrow, setmana: week, "cap-de-setmana": weekend, }; const paramsforfetch: fetcheventsparams = { page: 0, size: 10, }; // add date filters actualdate "tots" (actualdate !== "tots") { const selectedfunction = datefunctions[actualdate keyof typeof datefunctions] || today; const { } = selectedfunction(); paramsforfetch.from = tolocaldatestring(from); paramsforfetch.to = tolocaldatestring(until); } (place !== "catalunya") { paramsforfetch.place = place; } (finalcategory &amp;&amp; finalcategory !== "tots") { paramsforfetch.category = finalcategory; } // add distance/radius filter provided const distance = typeof search.distance === "string" ? search.distance : undefined; const lat = typeof search.lat === "string" ? search.lat : undefined; const lon = typeof search.lon === "string" ? search.lon : undefined; const query = typeof search.search === "string" ? search.search : undefined; // add distance/radius filter coordinates provided (lat &amp;&amp; lon) { (distance) { paramsforfetch.radius = parseint(distance); } paramsforfetch.lat = parsefloat(lat); paramsforfetch.lon = parsefloat(lon); } // add search query provided (query) { paramsforfetch.term = query; } let noeventsfound = false; let eventsresponse = await fetchevents(paramsforfetch); let events = eventsresponse?.content || []; (!events || events.length === 0) { const regionswithcities = await fetchregionswithcities(); const regionwithcities = regionswithcities.find((r) =&gt; r.cities.some((city) =&gt; city.value === place) ); (regionwithcities) { const regions = await fetchregions(); const regionwithslug = regions.find((r) =&gt; r.id === regionwithcities.id); (regionwithslug) { const { } = twoweeksdefault(); const fallbackparams: fetcheventsparams = { page: 0, size: 7, place: regionwithslug.slug, tolocaldatestring(from), tolocaldatestring(until), }; (finalcategory &amp;&amp; finalcategory !== "tots") { fallbackparams.category = finalcategory; } eventsresponse = await fetchevents(fallbackparams); events = eventsresponse?.content || []; noeventsfound = true; } } } // final fallback: still events, fetch latest events filters (like catalunya homepage) (!events || events.length === 0) { const { } = twoweeksdefault(); const latesteventsparams: fetcheventsparams = { page: 0, size: 7, tolocaldatestring(from), tolocaldatestring(until), // place, category, filters - get latest events }; eventsresponse = await fetchevents(latesteventsparams); events = eventsresponse?.content || []; noeventsfound = true; } const eventswithads = insertads(events); const placetypelabel: placetypeandlabel = await getplacetypeandlabel(place); const categorydata = categories.find((cat) =&gt; cat.slug === finalcategory); const pagedata = await generatepagesdata({ currentyear: new date().getfullyear(), place, bydate: actualdate bydateoptions, placetypelabel, category: finalcategory &amp;&amp; finalcategory !== "tots" ? finalcategory : undefined, categoryname: categorydata?.name, }); const serverhasmore = eventsresponse ? !eventsresponse.last &amp;&amp; eventswithads.length &lt; eventsresponse.totalelements : false; const validevents = eventswithads.filter(iseventsummaryresponsedto); const structureddata = validevents.length &gt; 0 ? generateitemliststructureddata( validevents, finalcategory &amp;&amp; finalcategory !== "tots" ? `esdeveniments ${finalcategory} ${place}` : `esdeveniments ${actualdate} ${place}` ) : null; return ( &lt;&gt; {/* json-ld structured data */} {structureddata &amp;&amp; ( &lt;script id={`events-${place}-${actualdate}`} type="application/ld+json" strategy="afterinteractive" dangerouslysetinnerhtml={{ __html: json.stringify(structureddata), }} /&gt; )} {/* server-rendered events content (seo optimized) */} &lt;hybrideventslist initialevents={eventswithads} placetypelabel={placetypelabel} pagedata={pagedata} noeventsfound={noeventsfound} place={place} category={finalcategory} date={actualdate} serverhasmore={serverhasmore} /&gt; {/* client-side interactive layer (search, filters, floating button) */} &lt;clientinteractivelayer categories={categories} placetypelabel={placetypelabel} /&gt; &lt;/&gt; ); }</file><file name="app/[place]/[byDate]/[category]/page.tsx">import { redirect } "next/navigation"; import script "next/script"; import { fetchevents, insertads } "@lib/api/events"; import { fetchcategories } "@lib/api/categories"; import { getplacetypeandlabel } "@utils/helpers"; import { generatepagesdata } "@components/partials/generatepagesdata"; import { buildpagemeta, generateitemliststructureddata, } "@components/partials/seo-meta"; import type { placetypeandlabel, pagedata, bydateoptions } "types/common"; import type { categorysummaryresponsedto } "types/api/category"; import { fetcheventsparams } "types/event"; import { filteredpageprops } "types/props"; import hybrideventslist "@components/ui/hybrideventslist"; import clientinteractivelayer "@components/ui/clientinteractivelayer"; import { parsefiltersfromurl, getredirecturl, urltofilterstate, gettopstaticcombinations, } "@utils/url-filters"; import { validateplaceorthrow, validateplaceformetadata, } "@utils/route-validation"; import { iseventsummaryresponsedto } "types/api/iseventsummaryresponsedto"; import { fetchregionswithcities, fetchregions } "@lib/api/regions"; import { tolocaldatestring } "@utils/helpers"; import { twoweeksdefault } "@lib/dates"; export const revalidate = 600; export async function generatemetadata({ params, }: { params: promise&lt;{ place: string; bydate: string; category: string }&gt;; }) { const { place, bydate, category } = await params; // security: validate place parameter const validation = validateplaceformetadata(place); (!validation.isvalid) { return validation.fallbackmetadata; } // fetch categories metadata generation first let categories: categorysummaryresponsedto[] = []; try { categories = await fetchcategories(); } catch (error) { console.error("error fetching categories metadata:", error); categories = []; } // parse filters metadata generation categories const parsed = parsefiltersfromurl( { place, date: bydate, category }, new urlsearchparams(), categories // passing categories like main function ); const filters = urltofilterstate(parsed); // find category name seo const categorydata = categories.find((cat) =&gt; cat.slug === filters.category); const placetypeandlabel: placetypeandlabel = await getplacetypeandlabel( filters.place ); const pagedata: pagedata = await generatepagesdata({ currentyear: new date().getfullyear(), place: filters.place, bydate: filters.bydate bydateoptions, placetypelabel: placetypeandlabel, category: filters.category !== "tots" ? filters.category : undefined, categoryname: categorydata?.name, }); return buildpagemeta({ title: pagedata.title, description: pagedata.metadescription, canonical: pagedata.canonical, }); } export async function generatestaticparams() { // generate static params top combinations // combinations generated on-demand isr const combinations = gettopstaticcombinations(); // transform returned format { place, date, category } { place, bydate, category } return combinations.map(({ place, date, category }) =&gt; ({ place, bydate: date, category, })); } export default async function filteredpage({ params, searchparams, }: filteredpageprops) { const { place, bydate, category } = await params; const search = await searchparams; // security: validate place parameter validateplaceorthrow(place); // convert searchparams urlsearchparams const urlsearchparams = new urlsearchparams(); object.entries(search).foreach(([key, value]) =&gt; { (typeof value === "string") { urlsearchparams.set(key, value); } else (array.isarray(value)) { urlsearchparams.set(key, value[0]); } }); // fetch dynamic categories parsing url validate category slugs let categories: categorysummaryresponsedto[] = []; try { categories = await fetchcategories(); } catch (error) { // continue without categories - use static fallbacks console.error("error fetching categories:", error); categories = []; // fallback empty array fetch fails } // parse filters url dynamic categories validation const parsed = parsefiltersfromurl( { place, date: bydate, category }, urlsearchparams, categories ); // check redirect needed non-canonical urls const redirecturl = getredirecturl(parsed); (redirecturl) { redirect(redirecturl); } // convert filterstate compatibility const filters = urltofilterstate(parsed); // get place type label const placetypeandlabel: placetypeandlabel = await getplacetypeandlabel( filters.place ); // prepare fetch params const fetchparams: fetcheventsparams = { place: filters.place, bydate: filters.bydate bydateoptions, istoday: filters.bydate === "tots", category: filters.category !== "tots" ? filters.category : undefined, term: filters.searchterm || undefined, }; // add distance/radius filter coordinates provided (filters.lat &amp;&amp; filters.lon) { (filters.distance !== undefined) { fetchparams.radius = filters.distance; } fetchparams.lat = filters.lat; fetchparams.lon = filters.lon; } // fetch events let eventsresponse = await fetchevents(fetchparams); let events = eventsresponse?.content || []; let noeventsfound = false; // check need fetch fallback events region (!events || events.length === 0) { const regionswithcities = await fetchregionswithcities(); const regionwithcities = regionswithcities.find((r) =&gt; r.cities.some((city) =&gt; city.value === filters.place) ); (regionwithcities) { const regions = await fetchregions(); const regionwithslug = regions.find((r) =&gt; r.id === regionwithcities.id); (regionwithslug) { // fetch events parent region without specific category filter const fallbackparams: fetcheventsparams = { page: 0, size: 7, place: regionwithslug.slug, bydate: filters.bydate bydateoptions, istoday: filters.bydate === "tots", }; eventsresponse = await fetchevents(fallbackparams); events = eventsresponse?.content || []; noeventsfound = true; } } } // final fallback: still events, fetch latest events filters (like catalunya homepage) (!events || events.length === 0) { const { } = twoweeksdefault(); const latesteventsparams: fetcheventsparams = { page: 0, size: 7, tolocaldatestring(from), tolocaldatestring(until), // place, category, filters - get latest events }; eventsresponse = await fetchevents(latesteventsparams); events = eventsresponse?.content || []; noeventsfound = true; } const eventswithads = insertads(events); // find category name seo const categorydata = categories.find((cat) =&gt; cat.slug === filters.category); // generate page data seo const pagedata: pagedata = await generatepagesdata({ currentyear: new date().getfullyear(), place: filters.place, bydate: filters.bydate bydateoptions, placetypelabel: placetypeandlabel, category: filters.category !== "tots" ? filters.category : undefined, categoryname: categorydata?.name, }); // generate json-ld structured data events const validevents = eventswithads.filter(iseventsummaryresponsedto); const structureddata = validevents.length &gt; 0 ? generateitemliststructureddata( validevents, categorydata ? `${categorydata.name} ${filters.place}` : `esdeveniments ${filters.place}` ) : null; return ( &lt;&gt; {/* json-ld structured data */} {structureddata &amp;&amp; ( &lt;script id={`events-${filters.place}-${filters.bydate}-${filters.category}`} type="application/ld+json" strategy="afterinteractive" dangerouslysetinnerhtml={{ __html: json.stringify(structureddata), }} /&gt; )} &lt;hybrideventslist initialevents={eventswithads} pagedata={pagedata} placetypelabel={placetypeandlabel} place={filters.place} category={filters.category} date={filters.bydate} serverhasmore={!eventsresponse?.last} noeventsfound={noeventsfound} /&gt; &lt;clientinteractivelayer categories={categories} placetypelabel={placetypeandlabel} /&gt; &lt;/&gt; ); }</file><file name="app/e/[eventId]/EventClient.tsx">"use client"; import { usestate, useeffect } "react"; import { usesearchparams } "next/navigation"; // import useonscreen "components/hooks/useonscreen"; import { sendgoogleevent } "@utils/analytics"; import type { eventdetailresponsedto } "types/api/event"; import eventnotifications "./components/eventnotifications"; import eventheader "./components/eventheader"; import eventcategories "./components/eventcategories"; import eventdescription "./components/eventdescription"; import eventcalendar "./components/eventcalendar"; import eventweather "./components/eventweather"; import eventlocation "./components/eventlocation"; // import { useeventmodals } "./hooks/useeventmodals"; // import eventmodals "./components/eventmodals"; import { // pencilicon, // informationcircleicon infoicon, globealticon webicon, speakerphoneicon, } "@heroicons/react/outline"; import adarticle "components/ui/adarticle"; // const tooltip = dynamic(() =&gt; import("components/ui/tooltip"), { // ssr: false, // }); // helper function calculate time event function calculatetimeuntil(startdate: string, enddate?: string): string { const = new date(); const eventstart = new date(startdate); const eventend = enddate ? new date(enddate) : null; // event already ended (eventend &amp;&amp; &gt; eventend) { return "l'esdeveniment ha finalitzat"; } // event currently ongoing (eventend &amp;&amp; &gt;= eventstart &amp;&amp; &lt;= eventend) { const timediff = eventend.gettime() - now.gettime(); const days = math.floor(timediff / (1000 * 60 * 60 * 24)); const hours = math.floor( (timediff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60) ); (days &gt; 0) { return `acaba en ${days} dies`; } else (hours &gt; 0) { return `acaba en ${hours} hores`; } else { return "l'esdeveniment acaba aviat"; } } // event started yet const timediff = eventstart.gettime() - now.gettime(); (timediff &lt;= 0) { return "l'esdeveniment ara"; } const days = math.floor(timediff / (1000 * 60 * 60 * 24)); const hours = math.floor( (timediff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60) ); (days &gt; 0) { return `comena en ${days} dies`; } else (hours &gt; 0) { return `comena en ${hours} hores`; } else { return "l'esdeveniment avui"; } } export default function eventclient({ event, }: { event: eventdetailresponsedto; }) { // const editmodalref = useref&lt;htmldivelement&gt;(null); // const iseditmodalvisible = useonscreen( // editmodalref react.refobject&lt;element&gt;, // { // freezeoncevisible: true, // } // ); const searchparams = usesearchparams() ?? new urlsearchparams(); const newevent = searchparams.get("newevent"); const edit_suggested = searchparams.get("edit_suggested") === "true"; const [showthankyoubanner, setshowthankyoubanner] = usestate(edit_suggested); // const { // openmodal, // setopenmodal, // opendeletereasonmodal, // setopenmodaldeletereasonmodal, // reasontodelete, // setreasontodelete, // onsenddeletereason, // onremove, // } = useeventmodals(); useeffect(() =&gt; { sendgoogleevent("view_event_page", {}); }, []); const slug = event.slug ?? ""; const title = event.title ?? ""; const cityname = event.city?.name || ""; const regionname = event.region?.name || ""; return ( &lt;&gt; &lt;eventnotifications newevent={!!newevent} title={title} slug={slug} showthankyoubanner={!!showthankyoubanner} setshowthankyoubanner={setshowthankyoubanner} /&gt; {/* event header */} &lt;eventheader title={title} /&gt; {/* event calendar */} &lt;eventcalendar event={event} /&gt; {/* location map toggle */} &lt;eventlocation location={event.location} cityname={cityname} regionname={regionname} /&gt; {/* event categories - better positioned essential info */} &lt;eventcategories categories={event.categories} place={event.region.slug} /&gt; {/* ad section */} &lt;div classname="w-full h-full flex justify-center items-start px-4 min-h-[250px] gap-2"&gt; &lt;speakerphoneicon classname="w-5 h-5 mt-1" /&gt; &lt;div classname="w-11/12 flex flex-col gap-4"&gt; &lt;h2&gt;contingut patrocinat&lt;/h2&gt; &lt;adarticle slot="9643657007" /&gt; &lt;/div&gt; &lt;/div&gt; {/* description */} &lt;eventdescription description={event.description} locationvalue={event.city.slug || event.region.slug} location={cityname || regionname} /&gt; {/* weather */} &lt;div classname="w-full"&gt; &lt;eventweather weather={event.weather} /&gt; &lt;/div&gt; {/* event details section */} &lt;div classname="w-full flex justify-center items-start gap-2 px-4"&gt; &lt;webicon classname="w-5 h-5 mt-1" /&gt; &lt;div classname="w-11/12 flex flex-col gap-4"&gt; &lt;h2&gt;detalls de l&amp;apos;esdeveniment&lt;/h2&gt; &lt;div classname="flex justify-start items-center gap-2"&gt; &lt;div classname="flex items-center gap-1 font-normal"&gt; {calculatetimeuntil(event.startdate, event.enddate)} &lt;/div&gt; &lt;/div&gt; {event.duration &amp;&amp; ( &lt;div classname="flex justify-start items-center gap-2"&gt; &lt;div classname="flex items-center gap-1 font-normal"&gt; durada aproximada: {event.duration} &lt;/div&gt; &lt;/div&gt; )} {event.url &amp;&amp; ( &lt;div classname="font-bold"&gt; enlla l&amp;apos;esdeveniment: classname="text-primary hover:underline font-normal ml-1" href={event.url} target="_blank" rel="noreferrer" &gt; {event.title} &lt;/div&gt; )} &lt;/div&gt; &lt;/div&gt; {/* edit button section */} {/* &lt;div classname="w-full flex justify-center items-start gap-2 px-4"&gt; &lt;pencilicon classname="w-5 h-5 mt-1" /&gt; &lt;div classname="w-11/12 flex flex-col gap-4"&gt; &lt;h2&gt;suggerir un canvi&lt;/h2&gt; {iseditmodalvisible &amp;&amp; ( &lt;div classname="w-11/12 flex justify-start items-center gap-2 cursor-pointer"&gt; &lt;div onclick={() =&gt; { setopenmodal(true); sendgoogleevent("open-change-modal", {}); }} classname="gap-2 ease-in-out duration-300 border-whitecorp hover:border-blackcorp" &gt; &lt;p classname="font-medium flex items-center"&gt;editar&lt;/p&gt; &lt;/div&gt; &lt;infoicon classname="w-5 h-5" data-tooltip-id="edit-button" /&gt; &lt;tooltip id="edit-button"&gt; si desprs de veure la informaci de l&amp;apos;esdeveniment, &lt;br /&gt; veus que hi ha alguna dada erronia vols ampliar la &lt;br /&gt; informaci, pots fer-ho al segent enlla. revisarem el &lt;br /&gt; canvi actualitzarem l&amp;apos;informaci. &lt;/tooltip&gt; &lt;/div&gt; )} &lt;/div&gt; &lt;/div&gt; */} {/* edit modal */} {/* &lt;div ref={editmodalref} classname="w-full"&gt; {iseditmodalvisible &amp;&amp; ( &lt;eventmodals openmodal={openmodal} setopenmodal={setopenmodal} opendeletereasonmodal={opendeletereasonmodal} setopenmodaldeletereasonmodal={setopenmodaldeletereasonmodal} reasontodelete={reasontodelete} setreasontodelete={setreasontodelete} onsenddeletereason={() =&gt; onsenddeletereason(string(event.id), event.title) } onremove={onremove} slug={event.slug} /&gt; )} &lt;/div&gt; */} &lt;/&gt; ); }</file><file name="app/e/[eventId]/page.tsx">import { generatejsondata } "@utils/helpers"; import { fetcheventbyid } "@lib/api/events"; import { eventdetailresponsedto } "types/api/event"; import { metadata } "next"; import { siteurl } "@config/index"; import { generateeventmetadata } "../../../lib/meta"; import { extractuuidfromslug } "@utils/string-helpers"; import { headers } "next/headers"; import script "next/script"; import eventmedia "./components/eventmedia"; import eventsharebar "./components/eventsharebar"; import eventclient "./eventclient"; import noeventfound "components/ui/common/noeventfound"; import eventsaroundsection "@components/ui/eventsaround/eventsaroundsection"; import { speakerphoneicon } "@heroicons/react/outline"; import adarticle "components/ui/adarticle"; // helper: metadata generation export async function generatemetadata(props: { params: promise&lt;{ eventid: string }&gt;; }): promise&lt;metadata&gt; { const slug = (await props.params).eventid; const uuid = extractuuidfromslug(slug); const event = await fetcheventbyid(uuid); (!event) return { title: event found" }; return generateeventmetadata(event, `${siteurl}/e/${slug}`); } // main page component export default async function eventpage({ params, }: { params: promise&lt;{ eventid: string }&gt;; }) { const slug = (await params).eventid; const uuid = extractuuidfromslug(slug); // read nonce middleware headers const headerslist = await headers(); const nonce = headerslist.get("x-nonce") || ""; const event: eventdetailresponsedto | null = await fetcheventbyid(uuid); (!event) return &lt;noeventfound /&gt;; (event.title === "cancelled") return &lt;noeventfound /&gt;; const eventslug = event?.slug ?? ""; const title = event?.title ?? ""; const cityname = event.city?.name || ""; const regionname = event.region?.name || ""; const eventdatestring = event.enddate ? `del ${event.startdate} al ${event.enddate}` : `${event.startdate}`; const jsondata = generatejsondata({ ...event }); // generate json-ld related events (server-side seo) const relatedeventsjsondata = event.relatedevents &amp;&amp; event.relatedevents.length &gt; 0 ? { "@id": `${siteurl}#itemlist-${title ?.tolowercase() .replace(/\s+/g, "-")}`, "@context": "https://schema.org", "@type": "itemlist", name: "related events", numberofitems: event.relatedevents.length, itemlistelement: event.relatedevents .slice(0, 10) // limit performance .map((relatedevent, index) =&gt; { try { return { "@type": "listitem", position: index + 1, item: generatejsondata(relatedevent), }; } catch (err) { console.error( "error generating json-ld related event:", relatedevent.id, err ); return null; } }) .filter(boolean), } : null; return ( &lt;&gt; {/* main event json-ld */} &lt;script id={event.id ? string(event.id) : undefined} type="application/ld+json" strategy="afterinteractive" nonce={nonce} dangerouslysetinnerhtml={{ __html: json.stringify(jsondata) }} /&gt; {/* related events json-ld */} {relatedeventsjsondata &amp;&amp; ( &lt;script id={`related-events-${event.id}`} type="application/ld+json" strategy="afterinteractive" nonce={nonce} dangerouslysetinnerhtml={{ __html: json.stringify(relatedeventsjsondata), }} /&gt; )} &lt;div classname="w-full flex justify-center bg-whitecorp pb-10"&gt; &lt;div classname="w-full flex flex-col justify-center items-center gap-4 sm:w-[520px] md:w-[520px] lg:w-[520px] min-w-0"&gt; &lt;article classname="w-full flex flex-col justify-center items-start gap-8"&gt; &lt;div classname="w-full flex flex-col justify-center items-start gap-4"&gt; &lt;eventmedia event={event} title={title} /&gt; &lt;eventsharebar visits={event.visits} slug={eventslug} title={title} description={event.description} eventdatestring={eventdatestring} location={event.location} cityname={cityname} regionname={regionname} postalcode={event.city?.postalcode || ""} /&gt; &lt;/div&gt; &lt;eventclient event={event} /&gt; {/* related events - server-side rendered seo */} {event.relatedevents &amp;&amp; event.relatedevents.length &gt; 0 &amp;&amp; ( &lt;eventsaroundsection events={event.relatedevents} title="esdeveniments relacionats" nonce={nonce} /&gt; )} {/* final ad section */} &lt;div classname="w-full h-full flex justify-center items-start px-4 min-h-[250px] gap-2"&gt; &lt;speakerphoneicon classname="w-5 h-5 mt-1" /&gt; &lt;div classname="w-11/12 flex flex-col gap-4"&gt; &lt;h2&gt;contingut patrocinat&lt;/h2&gt; &lt;adarticle slot="9643657007" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; &lt;/&gt; ); } export const revalidate = 1800;</file><file name="app/e/[eventId]/components/EventCalendar.tsx">import { calendaricon } "@heroicons/react/outline"; import { siteurl } "@config/index"; import { getformatteddate } "@utils/helpers"; import type { eventcalendarprops } "types/event"; import addtocalendar "@components/ui/addtocalendar"; export default function eventcalendar({ event }: eventcalendarprops) { // extract needed fields const { title, description, location, city, region, startdate, enddate, slug, starttime, endtime, } = event; const { formattedstart, formattedend, nameday } = getformatteddate( startdate, enddate ); const eventdate = formattedend ? `del ${formattedstart} al ${formattedend}` : `${nameday}, ${formattedstart}`; return ( &lt;div classname="w-full flex justify-center items-start gap-2 px-4"&gt; &lt;calendaricon classname="w-5 h-5 mt-1" /&gt; &lt;div classname="w-11/12 flex flex-col gap-4"&gt; &lt;h2&gt;data hora&lt;/h2&gt; &lt;div classname="w-full flex flex-col gap-4"&gt; &lt;p&gt;{eventdate}&lt;/p&gt; &lt;p classname="capitalize"&gt; {!starttime || starttime === "00:00" ? "consultar horaris" : `${starttime} - ${endtime || ""}`} &lt;/p&gt; &lt;/div&gt; &lt;addtocalendar title={title} description={description} location={`${location}, ${city?.name || ""}, ${region?.name || ""}, ${ city?.postalcode || "" }`} startdate={startdate} enddate={enddate} canonical={`${siteurl}/e/${slug}`} /&gt; &lt;/div&gt; &lt;/div&gt; ); }</file><file name="app/e/[eventId]/components/EventCategories.tsx">"use client"; import react "react"; import link "next/link"; import { tagicon } "@heroicons/react/outline"; import type { eventcategoriesprops } "types/event"; const eventcategories: react.fc&lt;eventcategoriesprops&gt; = ({ categories, place, }) =&gt; { (!categories || categories.length === 0) return null; return ( &lt;div classname="w-full flex justify-center items-start gap-2 px-4"&gt; &lt;tagicon classname="h-5 w-5 mt-1 text-blackcorp flex-shrink-0" aria-hidden="true" /&gt; &lt;div classname="w-11/12 flex flex-col gap-4"&gt; &lt;h2 classname="text-blackcorp font-semibold"&gt;categories&lt;/h2&gt; &lt;div classname="flex flex-wrap gap-3"&gt; {categories.map((category) =&gt; ( &lt;link key={category.id} href={`/${place}/${category.slug}`} classname="text-blackcorp bg-whitecorp hover:bg-primary hover:border-whitecorp hover:text-whitecorp border-blackcorp rounded-xl py-2 px-4 ease-in-out duration-300 border focus:outline-none font-barlow italic uppercase font-semibold tracking-wide text-sm" &gt; {category.name} &lt;/link&gt; ))} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); }; export default eventcategories;</file><file name="app/e/[eventId]/components/EventDescription.tsx">"use client"; import description "@components/ui/common/description"; import react "react"; import type { eventdescriptionprops } "types/event"; const eventdescription: react.fc&lt;eventdescriptionprops&gt; = ({ description, location, locationvalue, }) =&gt; { return ( &lt;div classname="w-full flex justify-center items-start gap-2 px-4"&gt; &lt;div classname="max-w-none text-gray-800"&gt; &lt;description description={description} location={location} locationvalue={locationvalue} /&gt; &lt;/div&gt; &lt;/div&gt; ); }; export default eventdescription;</file><file name="app/e/[eventId]/components/EventHeader.tsx">import react "react"; import type { eventheaderprops } "types/event"; const eventheader: react.fc&lt;eventheaderprops&gt; = ({ title }) =&gt; { return ( &lt;div classname="w-full flex flex-col justify-start items-start gap-2 px-4"&gt; &lt;h1 classname="text-2xl font-bold uppercase"&gt;{title}&lt;/h1&gt; &lt;/div&gt; ); }; export default eventheader;</file><file name="app/e/[eventId]/components/EventImage.tsx">"use client"; import { eventimageprops } "types/event"; import { fc } "react"; import image "@components/ui/common/image"; import imagedefault "components/ui/imgdefault"; const eventimage: fc&lt;eventimageprops&gt; = ({ image, title }) =&gt; { (!image) { return ( &lt;div classname="w-full"&gt; &lt;div classname="w-full border-t"&gt;&lt;/div&gt; &lt;imagedefault title={title} /&gt; &lt;/div&gt; ); } return ( href={image} classname="flex justify-center w-full" target="_blank" rel="noopener noreferrer" &gt; &lt;div classname="w-full" style={{ position: "relative", height: "260px" }}&gt; &lt;image title={title} alt={title} image={image} classname="w-full h-full object-cover" priority={true} context="detail" /&gt; &lt;/div&gt; ); }; export default eventimage;</file><file name="app/e/[eventId]/components/EventLocation.tsx">"use client"; import { usestate, useref } "react"; import { locationmarkericon locationicon, xicon, chevrondownicon, arrowrighticon, } "@heroicons/react/outline"; import dynamic "next/dynamic"; import { eventlocationprops } "types/event"; const maps = dynamic(() =&gt; import("components/ui/maps"), { ssr: false }); export default function eventlocation({ location, cityname, regionname, }: eventlocationprops) { const [showmap, setshowmap] = usestate(false); const [ismapsvisible, setismapsvisible] = usestate(false); const mapsdivref = useref(null); const handleshowmap = () =&gt; { setshowmap((prev) =&gt; !prev); settimeout(() =&gt; setismapsvisible(true), 100); // optional: delay smoothness }; const handledirectionsclick = () =&gt; { const query = encodeuricomponent(`${location}, ${cityname}, ${regionname}`); window.open( `https://www.google.com/maps/search/?api=1&amp;query=${query}`, "_blank" ); }; // check location already contains city information avoid duplication const locationcontainscity = location .tolowercase() .includes(cityname.tolowercase()); const shouldshowcityregion = !locationcontainscity &amp;&amp; cityname &amp;&amp; regionname; return ( &lt;&gt; &lt;div classname="w-full flex justify-center items-start gap-2 px-4"&gt; &lt;locationicon classname="h-5 w-5 mt-1" aria-hidden="true" /&gt; &lt;div classname="w-11/12 flex flex-col gap-4 pr-4"&gt; &lt;h2&gt;ubicaci&lt;/h2&gt; &lt;div classname="w-full flex flex-col justify-center items-center gap-4"&gt; &lt;div classname="w-full flex flex-col justify-center items-start gap-4"&gt; &lt;div classname="w-full flex flex-col justify-start items-start gap-1"&gt; &lt;p&gt;{location}&lt;/p&gt; {shouldshowcityregion &amp;&amp; ( &lt;p&gt; {cityname}, {regionname} &lt;/p&gt; )} &lt;/div&gt; &lt;div classname="w-fit flex justify-start items-center gap-2 border-b-2 border-whitecorp hover:border-b-2 hover:border-blackcorp ease-in-out duration-300 cursor-pointer" onclick={handleshowmap} &gt; &lt;button type="button" classname="flex gap-2"&gt; &lt;p classname="font-medium"&gt;mostrar mapa&lt;/p&gt; {showmap ? ( &lt;xicon classname="h-5 w-5" aria-hidden="true" /&gt; ) : ( &lt;chevrondownicon classname="h-5 w-5" aria-hidden="true" /&gt; )} &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; {showmap &amp;&amp; ( &lt;div classname="w-full flex flex-col justify-center items-end gap-6" ref={mapsdivref} &gt; {ismapsvisible &amp;&amp; &lt;maps location={location} /&gt;} &lt;div classname="w-fit flex justify-end items-center gap-2 px-4 border-b-2 border-whitecorp hover:border-b-2 hover:border-blackcorp ease-in-out duration-300 cursor-pointer"&gt; &lt;button classname="flex gap-2" onclick={handledirectionsclick}&gt; &lt;p classname="font-medium"&gt;com arribar&lt;/p&gt; &lt;arrowrighticon classname="w-5 h-5" /&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )} &lt;/&gt; ); }</file><file name="app/e/[eventId]/components/EventMedia.tsx">import react "react"; import dynamic "next/dynamic"; import type { eventmediaprops } "types/event"; import eventimage "./eventimage"; // videodisplay iframe, server-rendered const videodisplay = dynamic( () =&gt; import("components/ui/common/videodisplay"), { loading: () =&gt; ( &lt;div classname="w-full h-60 bg-darkcorp animate-pulse"&gt;&lt;/div&gt; ), } ); // imagedefault fallback cases const imagedefault = dynamic(() =&gt; import("components/ui/imgdefault"), { loading: () =&gt; &lt;div classname="w-full h-60 bg-darkcorp animate-pulse"&gt;&lt;/div&gt;, }); const eventmedia: react.fc&lt;eventmediaprops&gt; = ({ event, title }) =&gt; { // check video url - display video (event.videourl) { return ( &lt;div classname="w-full flex flex-col justify-center items-start gap-4 overflow-hidden"&gt; &lt;videodisplay videourl={event.videourl} /&gt; &lt;/div&gt; ); } // check image - display image using eventimage component (event.imageurl) { return ( &lt;div classname="w-full flex flex-col justify-center items-start gap-4 overflow-hidden"&gt; &lt;eventimage image={event.imageurl} title={title} /&gt; &lt;/div&gt; ); } // fallback default image return ( &lt;div classname="w-full flex flex-col justify-center items-start gap-4 overflow-hidden"&gt; &lt;imagedefault title={title} /&gt; &lt;/div&gt; ); }; export default eventmedia;</file><file name="app/e/[eventId]/components/EventModals.tsx">import react "react"; import editmodal "components/ui/editmodal"; import type { editmodalprops } "types/editmodal"; const eventmodals: react.fc&lt;editmodalprops&gt; = ({ openmodal, setopenmodal, opendeletereasonmodal, setopenmodaldeletereasonmodal, reasontodelete, setreasontodelete, onsenddeletereason, onremove, slug, }) =&gt; { return ( &lt;&gt; &lt;editmodal openmodal={openmodal} setopenmodal={setopenmodal} slug={slug} setopenmodaldeletereasonmodal={setopenmodaldeletereasonmodal} opendeletereasonmodal={opendeletereasonmodal} setreasontodelete={setreasontodelete} reasontodelete={reasontodelete} onsenddeletereason={onsenddeletereason} onremove={onremove} /&gt; {/* add modals needed */} &lt;/&gt; ); }; export default eventmodals;</file><file name="app/e/[eventId]/components/EventNotifications.tsx">import react "react"; import notification "components/ui/common/notification"; import type { eventnotificationsprops } "types/event"; const eventnotifications: react.fc&lt;eventnotificationsprops&gt; = ({ newevent, title, slug, showthankyoubanner, setshowthankyoubanner, }) =&gt; { return ( &lt;&gt; {newevent &amp;&amp; &lt;notification title={title} url={slug} /&gt;} {showthankyoubanner &amp;&amp; ( &lt;notification customnotification={false} hideclose hidenotification={setshowthankyoubanner} title="grcies per contribuir millorar el contingut de esdeveniments.cat! en menys de 24 hores estar disponible el canvi." /&gt; )} &lt;/&gt; ); }; export default eventnotifications;</file><file name="app/e/[eventId]/components/EventShareBar.tsx">"use client"; import cardsharebutton "components/ui/common/cardsharebutton"; import nativesharebutton "components/ui/common/nativesharebutton"; import viewcounter "components/ui/viewcounter"; import usecheckmobilescreen "components/hooks/usecheckmobilescreen"; import type { eventsharebarprops } "types/event"; export default function eventsharebar({ visits, slug, title, description, eventdatestring, location, cityname, regionname, postalcode, }: eventsharebarprops) { const ismobile = usecheckmobilescreen(); const cannativeshare = typeof window !== "undefined" &amp;&amp; !!navigator.share; const shownativeshare = ismobile &amp;&amp; cannativeshare; return ( &lt;div classname="w-full flex justify-between items-center px-4 h-2"&gt; {shownativeshare ? ( &lt;nativesharebutton title={title} text={description} url={slug} date={eventdatestring} location={location} sublocation={`${cityname}, ${regionname}, ${postalcode}`} /&gt; ) : ( &lt;cardsharebutton slug={slug} /&gt; )} &lt;viewcounter visits={visits} /&gt; &lt;/div&gt; ); }</file><file name="app/e/[eventId]/components/EventTags.tsx">"use client"; import react "react"; import type { eventtagsprops } "types/event"; const eventtags: react.fc&lt;eventtagsprops&gt; = ({ tags }) =&gt; { (!tags || tags.length === 0) return null; return ( &lt;div classname="w-full px-4 pb-2 flex flex-wrap gap-2"&gt; {tags.map((tag) =&gt; ( &lt;span key={tag} classname="bg-gray-200 text-gray-700 rounded-full px-3 py-1 text-xs font-medium" &gt; {tag} &lt;/span&gt; ))} &lt;/div&gt; ); }; export default eventtags;</file><file name="app/e/[eventId]/components/EventWeather.tsx">import react "react"; import dynamic "next/dynamic"; import { cloudicon } "@heroicons/react/outline"; import type { eventweatherprops } "types/event"; const weather = dynamic(() =&gt; import("components/ui/weather"), { ssr: false }); const eventweather: react.fc&lt;eventweatherprops&gt; = ({ weather }) =&gt; { (!weather) return null; return ( &lt;div classname="w-full flex justify-center items-start gap-2 px-4" data-testid="event-weather" &gt; &lt;cloudicon classname="w-5 h-5 mt-1" /&gt; &lt;div classname="w-11/12 flex flex-col gap-4"&gt; &lt;h2&gt;el temps&lt;/h2&gt; &lt;weather weather={weather} /&gt; &lt;/div&gt; &lt;/div&gt; ); }; export default eventweather;</file><file name="app/e/[eventId]/edita/EditEventClient.tsx">"use client"; import { userouter } "next/navigation"; import { usestate, usememo, usetransition } "react"; import eventform "@components/ui/eventform"; import type { formdata } "types/event"; import { editevent } "./actions"; import { formdatatobackenddto, eventdtotoformdata } "@utils/helpers"; import { eventsummaryresponsedto } "types/api/event"; import { regionsgroupedbycitiesresponsedto } "types/api/region"; import { option } "types/common"; import { usecategories } "@components/hooks/usecategories"; export default function editeventclient({ event, regions, }: { event: eventsummaryresponsedto; regions: regionsgroupedbycitiesresponsedto[] | null; }) { const router = userouter(); const [form, setform] = usestate&lt;formdata&gt;(eventdtotoformdata(event)); const [imagetoupload, setimagetoupload] = usestate&lt;string | null&gt;( form.imageurl ); const [progress] = usestate&lt;number&gt;(0); const [ispending, starttransition] = usetransition(); // fetch categories const { categories, isloading: isloadingcategories } = usecategories(); const regionoptions = usememo( () =&gt; regions ? regions.map((region) =&gt; ({ label: region.name, value: region.id.tostring(), })) : [], [regions] ); const categoryoptions = usememo( () =&gt; categories.map((category) =&gt; ({ label: category.name, value: category.id.tostring(), })), [categories] ); const cityoptions = usememo(() =&gt; { (!regions || !form.region) return []; const region = regions.find( (r) =&gt; r.id.tostring() === (form.region &amp;&amp; "value" form.region ? form.region.value : "") ); return region ? region.cities.map((city) =&gt; ({ id: city.id, label: city.label, value: city.id.tostring(), // use id value proper form handling })) : []; }, [regions, form.region]); // simple form change handler - validation const handleformchange = &lt;k extends keyof formdata&gt;( name: k, value: formdata[k] ) =&gt; { setform({ ...form, [name]: value }); }; const handleregionchange = (region: option | null) =&gt; handleformchange("region", region); const handletownchange = (town: option | null) =&gt; handleformchange("town", town); const handlecategorieschange = (categories: option[]) =&gt; handleformchange("categories", categories); const handleimagechange = (file: file) =&gt; { const reader = new filereader(); reader.addeventlistener("load", () =&gt; { setimagetoupload(reader.result string); }); reader.readasdataurl(file); }; async function onsubmit() { // eventform component handle validation internally // called validation passes starttransition(async () =&gt; { try { (!event) return; const data = formdatatobackenddto(form); const result = await editevent(event.id, data); (result &amp;&amp; result.success) { router.push(`/e/${event.id}/${event.slug}`); } else { console.error("error updating event"); } } catch (error) { console.error("error updating event:", error); } }); } return ( &lt;div&gt; &lt;h1&gt;edita: {event.title}&lt;/h1&gt; &lt;eventform form={form} onsubmit={onsubmit} submitlabel="desa canvis" iseditmode={true} isloading={ispending} regionoptions={regionoptions} cityoptions={cityoptions} categoryoptions={categoryoptions} isloadingcategories={isloadingcategories} handleformchange={handleformchange} handleimagechange={handleimagechange} handleregionchange={handleregionchange} handletownchange={handletownchange} handlecategorieschange={handlecategorieschange} progress={progress} imagetoupload={imagetoupload} /&gt; &lt;/div&gt; ); }</file><file name="app/e/[eventId]/edita/actions.ts">"use server"; import { revalidatepath } "next/cache"; import { updateeventbyid } "lib/api/events"; import type { eventupdaterequestdto } "types/api/event"; export async function editevent(eventid: string, data: eventupdaterequestdto) { // 1. update event backend await updateeventbyid(eventid, data); // 2. revalidate event detail page (purge isr cache) await revalidatepath(`/e/${eventid}`); // 3. optionally, return result client return { success: true }; }</file><file name="app/e/[eventId]/edita/page.tsx">import { notfound } "next/navigation"; import { fetcheventbyid } "lib/api/events"; import { fetchregionswithcities } "lib/api/regions"; import { extractuuidfromslug } "@utils/string-helpers"; import editeventclient "./editeventclient"; export default async function editapage({ params, }: { params: promise&lt;{ eventid: string }&gt;; }) { const slug = (await params).eventid; const uuid = extractuuidfromslug(slug); const event = await fetcheventbyid(uuid); const regionswithcities = await fetchregionswithcities(); (!event || !regionswithcities) return notfound(); return &lt;editeventclient event={event} regions={regionswithcities} /&gt;; }</file><file name="app/e/[eventId]/hooks/useEventAnalytics.ts">// hook analytics events event detail page export function useeventanalytics() { // todo: implement analytics tracking logic }</file><file name="app/e/[eventId]/hooks/useEventModals.ts">// hook modal state transitions import { usestate } "react"; import { sendgoogleevent } "@utils/analytics"; import type { deletereason } "types/event"; export function useeventmodals() { const [openmodal, setopenmodal] = usestate(false); const [opendeletereasonmodal, setopenmodaldeletereasonmodal] = usestate(false); const [reasontodelete, setreasontodelete] = usestate&lt;deletereason&gt;(null); const [showthankyoubanner, setshowthankyoubanner] = usestate(false); const onsenddeletereason = async (eventid: string, eventtitle: string) =&gt; { setopenmodaldeletereasonmodal(false); const rawresponse = await fetch(process.env.next_public_delete_event!, { method: "delete", headers: { accept: "application/json", "content-type": "application/json", }, body: json.stringify({ id: eventid, title: eventtitle, reason: reasontodelete, isproduction: process.env.node_env === "production", }), }); const { success } = await rawresponse.json(); (success) setshowthankyoubanner(true); sendgoogleevent("send-delete", { value: reasontodelete, }); }; const onremove = () =&gt; { setopenmodal(false); settimeout(() =&gt; setopenmodaldeletereasonmodal(true), 300); sendgoogleevent("open-delete-modal", {}); }; return { openmodal, setopenmodal, opendeletereasonmodal, setopenmodaldeletereasonmodal, reasontodelete, setreasontodelete, showthankyoubanner, setshowthankyoubanner, onsenddeletereason, onremove, }; }</file><file name="app/e/[eventId]/types/event.ts" /><file name="app/offline/page.tsx">export default function offlinepage() { return ( &lt;div classname="min-h-screen flex items-center justify-center bg-gray-50"&gt; &lt;div classname="text-center"&gt; &lt;h1 classname="text-4xl font-bold text-gray-900 mb-4"&gt; sense connexi &lt;/h1&gt; &lt;p classname="text-lg text-gray-600 mb-8"&gt; pots connectar-te internet. alguns continguts emmagatzemats podrien estar disponibles. &lt;/p&gt; href="/" classname="inline-block bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded" &gt; torna l&amp;apos;inici &lt;br /&gt; href="/barcelona" classname="inline-block mt-4 bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded mr-2" &gt; barcelona href="/catalunya" classname="inline-block mt-4 bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded" &gt; catalunya &lt;/div&gt; &lt;/div&gt; ); }</file><file name="app/publica/actions.ts">"use server"; import { revalidatepath } "next/cache"; import { createevent } "lib/api/events"; import type { eventcreaterequestdto } "types/api/event"; export async function createeventaction( data: eventcreaterequestdto, imagefile?: file ) { // 1. create event backend const created = await createevent(data, imagefile); // 2. revalidate event list page (purge isr cache) await revalidatepath("/e"); // 3. optionally, return created event result client return { success: true, event: created }; }</file><file name="app/publica/layout.tsx">import { reactnode } "react"; import { buildpagemeta } "@components/partials/seo-meta"; import { siteurl } "@config/index"; export const metadata = buildpagemeta({ title: "publica - esdeveniments.cat", description: "publica un acte cultural - esdeveniments.cat", canonical: `${siteurl}/publica`, }); export default function publicalayout({ children }: { children: reactnode }) { return children; }</file><file name="app/publica/page.tsx">"use client"; import { usestate, usememo, usetransition } "react"; import { userouter } "next/navigation"; import { captureexception } "@sentry/nextjs"; import { getregionvalue, formdatatobackenddto } "@utils/helpers"; import eventform "@components/ui/eventform"; import { usegetregionswithcities } "@components/hooks/usegetregionswithcities"; import { usecategories } "@components/hooks/usecategories"; import { createeventaction } "./actions"; import type { formdata } "types/event"; import { option } "types/common"; const defaultform: formdata = { title: "", description: "", type: "free", startdate: (() =&gt; { const = new date(); now.sethours(9, 0, 0, 0); return now.toisostring().slice(0, 16); })(), starttime: "", enddate: (() =&gt; { const = new date(); now.sethours(10, 0, 0, 0); return now.toisostring().slice(0, 16); })(), endtime: "", region: null, town: null, location: "", imageurl: null, url: "", categories: [], email: "", }; const publica = () =&gt; { const router = userouter(); const [form, setform] = usestate&lt;formdata&gt;(defaultform); const [imagefile, setimagefile] = usestate&lt;file | null&gt;(null); const [imagepreview, setimagepreview] = usestate&lt;string | null&gt;(null); const [ispending, starttransition] = usetransition(); const { regionswithcities, isloading: isloadingregionswithcities } = usegetregionswithcities(); const { categories } = usecategories(); const regionoptions = usememo( () =&gt; regionswithcities ? regionswithcities.map((region) =&gt; ({ label: region.name, value: region.id.tostring(), })) : [], [regionswithcities] ); const cityoptions = usememo(() =&gt; { (!regionswithcities || !form.region) return []; const regionid = getregionvalue(form.region); (!regionid) return []; const region = regionswithcities.find((r) =&gt; r.id.tostring() === regionid); return region ? region.cities.map((city) =&gt; ({ id: city.id, label: city.label, value: city.id.tostring(), })) : []; }, [regionswithcities, form.region]); const categoryoptions = usememo( () =&gt; categories.map((category) =&gt; ({ label: category.name, value: category.id.tostring(), })), [categories] ); const handleformchange = &lt;k extends keyof formdata&gt;( name: k, value: formdata[k] ) =&gt; { setform({ ...form, [name]: value }); }; const handleregionchange = (region: option | null) =&gt; { handleformchange("region", region); }; const handleimagechange = (file: file) =&gt; { setimagefile(file); const reader = new filereader(); reader.addeventlistener("load", () =&gt; { setimagepreview(reader.result string); }); reader.readasdataurl(file); }; const handletownchange = (town: option | null) =&gt; handleformchange("town", town); const handlecategorieschange = (categories: option[]) =&gt; handleformchange("categories", categories); const onsubmit = async () =&gt; { starttransition(async () =&gt; { try { const regionlabel = form.region &amp;&amp; "label" form.region ? form.region.label : ""; const townlabel = form.town &amp;&amp; "label" form.town ? form.town.label : ""; const location = `${form.location}, ${townlabel}, ${regionlabel}`; const eventdata = formdatatobackenddto({ ...form, location, }); const result = await createeventaction( eventdata, imagefile || undefined ); (result &amp;&amp; result.success &amp;&amp; result.event) { const { slug } = result.event; router.push(`/e/${slug}`); } else { captureexception("error creating event"); } } catch (error) { console.error("submission error:", error); captureexception(error); } }); }; return ( &lt;div classname="w-full flex flex-col justify-center items-center pt-2 pb-14 sm:w-[580px] md:w-[768px] lg:w-[1024px] px-4 md:px-0"&gt; &lt;div classname="flex flex-col items-center gap-4"&gt; &lt;div classname="flex flex-col items-center gap-2"&gt; &lt;h1 classname="text-center italic uppercase font-semibold"&gt; publica un esdeveniment &lt;/h1&gt; &lt;p classname="text-sm text-center"&gt;* camps obligatoris&lt;/p&gt; &lt;/div&gt; &lt;div classname="w-full flex flex-col justify-center items-center gap-y-4 pt-4 sm:w-[580px] md:w-[768px] lg:w-[1024px]"&gt; &lt;eventform form={form} onsubmit={onsubmit} submitlabel="publicar" isloading={ispending} regionoptions={regionoptions} cityoptions={cityoptions} categoryoptions={categoryoptions} progress={0} isloadingregionswithcities={isloadingregionswithcities} handleformchange={handleformchange} handleimagechange={handleimagechange} handleregionchange={handleregionchange} handletownchange={handletownchange} handlecategorieschange={handlecategorieschange} imagetoupload={imagepreview} imagefile={imagefile} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); }; export default publica;</file><file name="app/qui-som/page.tsx">import link "next/link"; import { siteurl } "@config/index"; import image "next/image"; import type { nextpage } "next"; import type { teammember teammembertype } "types/common"; import { buildpagemeta } "@components/partials/seo-meta"; export const metadata = buildpagemeta({ title: "qui som - esdeveniments.cat", description: "qui som? - esdeveniments.cat una iniciativa ciutadana per veure en un cop d'ull tots els actes culturals que es fan catalunya.", canonical: `${siteurl}/qui-som`, }); const teammembers: teammembertype[] = [ { name: "albert oliv corbella", role: "senior full stack developer", title: "cto fundador", image: "/static/images/linkedin_albert.jpeg", linkedin: "https://www.linkedin.com/in/albertolivecorbella/", }, { name: "andreu bentez moreno", role: "ui engineer | graphic designer", title: "co-fundador", image: "/static/images/linkedin_andreu.jpeg", linkedin: "https://www.linkedin.com/in/andreubenitezmoreno/", }, { name: "gerard rovellat carb", role: "software engineer | backend developer", title: "co-fundador", image: "/static/images/linkedin_gerard.jpg", linkedin: "https://www.linkedin.com/in/gerardrovellatcarbo/", }, ]; const quisom: nextpage = () =&gt; { return ( &lt;div classname="w-full flex flex-col justify-center items-center gap-10 pt-2 pb-14 sm:w-[580px] md:w-[768px] lg:w-[1024px] px-4 md:px-0"&gt; &lt;div&gt; &lt;h1 classname="text-center italic uppercase font-semibold"&gt;qui som?&lt;/h1&gt; &lt;h3 classname="text-center italic font-normal text-primary"&gt; esdeveniments.cat &lt;/h3&gt; &lt;/div&gt; &lt;div classname="fl