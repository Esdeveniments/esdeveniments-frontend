/**
 * Business Lead Scraper ‚Äî extracts real businesses from council directories.
 *
 * How it works:
 * 1. Reads council websites from leads.csv (generated by generate-leads.mjs)
 * 2. For each council, tries /adreces-i-telefons (DIBA CMS standard directory)
 * 3. Paginates through all pages, extracts business name + category + email
 * 4. Filters to relevant business categories (restaurants, shops, culture, etc.)
 * 5. Outputs business-leads.csv ready for outreach
 *
 * Output: scripts/output/business-leads.csv
 *
 * Usage:
 *   node scripts/scrape-business-leads.mjs
 *
 * Prerequisites:
 *   Run generate-leads.mjs first to create scripts/output/leads.csv
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/** Delay between requests (ms) ‚Äî be polite to council servers */
const REQUEST_DELAY_MS = 800;

/** Timeout per request */
const FETCH_TIMEOUT_MS = 10000;

/** Max pages to scrape per council (safety limit) */
const MAX_PAGES_PER_COUNCIL = 30;

/** Directory paths to try on each council website */
const DIRECTORY_PATHS = [
  "/adreces-i-telefons",
  "/guia/adreces-i-telefons",
  "/municipi/guia-del-municipi/empreses-i-comercos",
];

/**
 * Categories of businesses worth contacting (in Catalan/Spanish).
 * These are people who'd benefit from advertising on an events platform.
 * null = accept all (some councils don't have categories).
 */
const RELEVANT_CATEGORIES = [
  // Food & drink
  "bar",
  "restaurant",
  "cafeteria",
  "pastisseria",
  "forn",
  "fleca",
  "pizzeria",
  "celler",
  "bodega",
  "cerveseria",
  "gelat",
  // Hospitality
  "hotel",
  "hostal",
  "allotjament",
  "turisme",
  "rural",
  "c√†mping",
  "camping",
  "col√≤ni",
  // Shopping / retail
  "comer√ß",
  "botiga",
  "floristeria",
  "moda",
  "roba",
  "cal√ßat",
  "complement",
  "joieria",
  "optic",
  "perfumeria",
  "ferreteria",
  "electrodom√®stic",
  "moble",
  "decoraci√≥",
  "regal",
  "llibreria",
  "papereria",
  "esport",
  // Culture & leisure
  "cultur",
  "teatre",
  "cinema",
  "museu",
  "galeria",
  "art",
  "m√∫sica",
  "dansa",
  "ball",
  "oci",
  "lleure",
  "centre c√≠v",
  "casal",
  // Wellness & health
  "perruqueria",
  "bellesa",
  "est√®tica",
  "spa",
  "gimn√†s",
  "fitness",
  "ioga",
  "yoga",
  // Services people seek near events
  "taxi",
  "aparcament",
  "p√†rking",
  "immobili",
  "fotograf",
  "academia",
  "escola",
  "autoescola",
  // General commerce
  "supermercat",
  "mercat",
  "alimentaci√≥",
  "fruiter",
  "carnisseria",
  "xarcuteria",
  "peix",
];

/**
 * Categories to SKIP (associations, government, schools, etc.)
 */
const SKIP_PATTERNS = [
  "ampa",
  "afa ",
  "a.m.p.a",
  "ajuntament",
  "policia",
  "bombers",
  "generalitat",
  "diputaci√≥",
  "govern",
  "jutjat",
  "correos",
  "cap -",
  "centre d'atenci√≥ prim√†ria",
  "serveis socials",
  "protecci√≥ civil",
  "agrupaci√≥ defensa forestal",
];

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Fetch a page with timeout.
 */
async function fetchPage(url) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
  try {
    const res = await fetch(url, {
      signal: controller.signal,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (compatible; esdeveniments.cat lead-gen/1.0)",
        Accept: "text/html",
      },
      redirect: "follow",
    });
    clearTimeout(timeout);
    if (!res.ok) return null;
    return await res.text();
  } catch {
    clearTimeout(timeout);
    return null;
  }
}

/**
 * Extract business entries from a DIBA CMS directory page.
 * Pattern: <p class="subtitle">NAME</p> ... <div class="entradeta"><p>CATEGORY</p> ... <a href="mailto:EMAIL">
 */
function extractBusinessEntries(html) {
  const entries = [];

  // Split by each entry block ‚Äî they use class="subtitle" for names
  // We'll use a regex approach to find name + optional category + optional email
  const entryRegex =
    /<p class="subtitle">\s*(.*?)\s*<\/p>[\s\S]*?(?:<div class="entradeta"><p>(.*?)<\/p>)?[\s\S]*?(?:<a href="mailto:([^"]+)")?/g;

  // Better approach: find all subtitle entries, then look ahead for category and email
  const subtitleRegex = /<p class="subtitle">\s*([^<]+)\s*<\/p>/g;
  const subtitles = [];
  let match;
  while ((match = subtitleRegex.exec(html)) !== null) {
    subtitles.push({ name: match[1].trim(), index: match.index });
  }

  for (let i = 0; i < subtitles.length; i++) {
    const start = subtitles[i].index;
    const end = i + 1 < subtitles.length ? subtitles[i + 1].index : html.length;
    const block = html.substring(start, end);

    const name = subtitles[i].name;

    // Extract category (entradeta)
    const catMatch = block.match(
      /<div class="entradeta"><p>\s*([\s\S]*?)\s*<\/p>/,
    );
    const category = catMatch ? catMatch[1].replace(/<[^>]*>/g, "").trim() : "";

    // Extract email
    const emailMatch = block.match(/href="mailto:([^"]+)"/);
    const email = emailMatch ? emailMatch[1].trim().toLowerCase() : "";

    if (name) {
      entries.push({ name, category, email });
    }
  }

  return entries;
}

/**
 * Find the max page number from the HTML pagination links.
 */
function findMaxPage(html) {
  const pageRegex = /[?&]pag=(\d+)/g;
  let max = 1;
  let match;
  while ((match = pageRegex.exec(html)) !== null) {
    const pageNum = parseInt(match[1], 10);
    if (pageNum > max) max = pageNum;
  }
  return max;
}

/**
 * Check if a business name should be skipped.
 */
function shouldSkipBusiness(name) {
  const lower = name.toLowerCase();
  return SKIP_PATTERNS.some((pattern) => lower.includes(pattern));
}

/**
 * Check if a business is in a relevant category.
 * If no category is available, accept it (better to over-include).
 */
function isRelevantCategory(category) {
  if (!category) return true; // No category info ‚Üí include it
  const lower = category.toLowerCase();
  return RELEVANT_CATEGORIES.some((cat) => lower.includes(cat));
}

/**
 * Escape CSV field.
 */
function csvEscape(value) {
  if (!value) return "";
  const str = String(value);
  if (str.includes(",") || str.includes('"') || str.includes("\n")) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

/**
 * Parse leads.csv to get council websites.
 */
function parseLeadsCSV(csvPath) {
  const content = fs.readFileSync(csvPath, "utf-8");
  const lines = content.split("\n").filter((l) => l.trim());
  // Skip header
  const councils = [];
  for (let i = 1; i < lines.length; i++) {
    // Simple CSV parsing (handles our known format)
    const parts = lines[i].split(",");
    if (parts.length >= 8) {
      councils.push({
        name: parts[0],
        city: parts[1],
        region: parts[2],
        website: parts[3],
        citySlug: parts[7],
      });
    }
  }
  return councils;
}

async function main() {
  console.log(
    "üîç Business Lead Scraper ‚Äî Finding real businesses in your towns\n",
  );

  const leadsPath = path.join(__dirname, "output", "leads.csv");
  if (!fs.existsSync(leadsPath)) {
    console.error("‚ùå leads.csv not found. Run generate-leads.mjs first.");
    process.exit(1);
  }

  const councils = parseLeadsCSV(leadsPath);
  console.log(`üìã Found ${councils.length} councils from leads.csv\n`);

  // All business leads across all councils
  const allBusinesses = [];
  let councilsWithDirectory = 0;
  let councilsWithoutDirectory = 0;

  for (let c = 0; c < councils.length; c++) {
    const council = councils[c];
    process.stdout.write(`[${c + 1}/${councils.length}] ${council.name}... `);

    // Try each directory path
    let directoryFound = false;

    for (const dirPath of DIRECTORY_PATHS) {
      const baseUrl = `${council.website}${dirPath}`;
      const html = await fetchPage(baseUrl);

      if (!html || !html.includes('class="subtitle"')) {
        await sleep(300); // Small delay even for misses
        continue;
      }

      directoryFound = true;
      councilsWithDirectory++;

      // Find max page
      const maxPage = findMaxPage(html);
      process.stdout.write(`found! ${maxPage} pages ‚Üí `);

      let totalEntries = 0;
      let withEmail = 0;

      // Scrape all pages
      for (
        let page = 1;
        page <= Math.min(maxPage, MAX_PAGES_PER_COUNCIL);
        page++
      ) {
        const pageUrl = page === 1 ? baseUrl : `${baseUrl}?pag=${page}`;
        const pageHtml = page === 1 ? html : await fetchPage(pageUrl);

        if (!pageHtml) continue;

        const entries = extractBusinessEntries(pageHtml);

        for (const entry of entries) {
          // Skip non-business entries
          if (shouldSkipBusiness(entry.name)) continue;

          // Only keep relevant categories
          if (!isRelevantCategory(entry.category)) continue;

          totalEntries++;
          if (entry.email) withEmail++;

          allBusinesses.push({
            businessName: entry.name,
            category: entry.category,
            email: entry.email,
            town: council.city,
            region: council.region,
            councilWebsite: council.website,
            citySlug: council.citySlug,
          });
        }

        if (page < maxPage) await sleep(REQUEST_DELAY_MS);
      }

      console.log(`${totalEntries} businesses (${withEmail} with email)`);
      break; // Found directory, no need to try other paths
    }

    if (!directoryFound) {
      councilsWithoutDirectory++;
      console.log("no directory found");
    }

    await sleep(REQUEST_DELAY_MS);
  }

  // Deduplicate by email (same business might appear in multiple places)
  const seenEmails = new Set();
  const uniqueBusinesses = [];
  const noEmailBusinesses = [];

  for (const biz of allBusinesses) {
    if (biz.email) {
      if (!seenEmails.has(biz.email)) {
        seenEmails.add(biz.email);
        uniqueBusinesses.push(biz);
      }
    } else {
      noEmailBusinesses.push(biz);
    }
  }

  // Sort: businesses with emails first, then by town
  const finalList = [
    ...uniqueBusinesses.sort((a, b) => a.town.localeCompare(b.town)),
    ...noEmailBusinesses.sort((a, b) => a.town.localeCompare(b.town)),
  ];

  // Write CSV
  const outputDir = path.join(__dirname, "output");
  if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

  const csvPath = path.join(outputDir, "business-leads.csv");
  const headers = [
    "Business Name",
    "Category",
    "Email",
    "Town",
    "Region",
    "Council Website",
    "City Slug (for targeting)",
  ];

  const rows = finalList.map((b) => [
    csvEscape(b.businessName),
    csvEscape(b.category),
    csvEscape(b.email),
    csvEscape(b.town),
    csvEscape(b.region),
    csvEscape(b.councilWebsite),
    csvEscape(b.citySlug),
  ]);

  const csv = [headers.join(","), ...rows.map((r) => r.join(","))].join("\n");
  fs.writeFileSync(csvPath, csv, "utf-8");

  // Summary
  console.log("\n" + "=".repeat(60));
  console.log("üìä RESULTS\n");
  console.log(`   Councils with directory:    ${councilsWithDirectory}`);
  console.log(`   Councils without directory: ${councilsWithoutDirectory}`);
  console.log(`   Total businesses found:     ${allBusinesses.length}`);
  console.log(`   Unique with email:          ${uniqueBusinesses.length}`);
  console.log(`   Without email:              ${noEmailBusinesses.length}`);
  console.log(`\nüìÑ Saved to: scripts/output/business-leads.csv`);

  // Top towns by business count
  const townCounts = {};
  for (const b of allBusinesses) {
    townCounts[b.town] = (townCounts[b.town] || 0) + 1;
  }
  const topTowns = Object.entries(townCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);

  console.log("\nüèòÔ∏è  Top 10 towns by business count:\n");
  for (const [town, count] of topTowns) {
    console.log(`   ${town.padEnd(30)} ${count} businesses`);
  }

  // Show some example leads with emails
  const examplesWithEmail = uniqueBusinesses.slice(0, 10);
  if (examplesWithEmail.length > 0) {
    console.log("\nüìß Sample leads with emails:\n");
    for (const b of examplesWithEmail) {
      console.log(
        `   ${b.businessName.substring(0, 30).padEnd(32)} ${(b.category || "‚Äî").substring(0, 30).padEnd(32)} ${b.email}`,
      );
    }
  }
}

main().catch((err) => {
  console.error("‚ùå Fatal error:", err.message);
  process.exit(1);
});
